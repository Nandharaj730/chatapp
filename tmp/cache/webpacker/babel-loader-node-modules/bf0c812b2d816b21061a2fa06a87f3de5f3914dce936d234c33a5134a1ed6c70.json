{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Generator = require(\"../Generator\");\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\nconst WebAssemblyImportDependency = require(\"../dependencies/WebAssemblyImportDependency\");\nconst WebAssemblyInInitialChunkError = require(\"./WebAssemblyInInitialChunkError\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nlet WebAssemblyGenerator;\nlet WebAssemblyJavascriptGenerator;\nlet WebAssemblyParser;\nclass WebAssemblyModulesPlugin {\n  constructor(options) {\n    this.options = options;\n  }\n\n  /**\n   * @param {Compiler} compiler compiler\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"WebAssemblyModulesPlugin\", (compilation, _ref) => {\n      let normalModuleFactory = _ref.normalModuleFactory;\n      compilation.dependencyFactories.set(WebAssemblyImportDependency, normalModuleFactory);\n      compilation.dependencyFactories.set(WebAssemblyExportImportedDependency, normalModuleFactory);\n      normalModuleFactory.hooks.createParser.for(\"webassembly/experimental\").tap(\"WebAssemblyModulesPlugin\", () => {\n        if (WebAssemblyParser === undefined) {\n          WebAssemblyParser = require(\"./WebAssemblyParser\");\n        }\n        return new WebAssemblyParser();\n      });\n      normalModuleFactory.hooks.createGenerator.for(\"webassembly/experimental\").tap(\"WebAssemblyModulesPlugin\", () => {\n        if (WebAssemblyGenerator === undefined) {\n          WebAssemblyGenerator = require(\"./WebAssemblyGenerator\");\n        }\n        if (WebAssemblyJavascriptGenerator === undefined) {\n          WebAssemblyJavascriptGenerator = require(\"./WebAssemblyJavascriptGenerator\");\n        }\n        return Generator.byType({\n          javascript: new WebAssemblyJavascriptGenerator(),\n          webassembly: new WebAssemblyGenerator(this.options)\n        });\n      });\n      compilation.chunkTemplate.hooks.renderManifest.tap(\"WebAssemblyModulesPlugin\", (result, options) => {\n        const chunk = options.chunk;\n        const outputOptions = options.outputOptions;\n        const moduleTemplates = options.moduleTemplates;\n        const dependencyTemplates = options.dependencyTemplates;\n        for (const module of chunk.modulesIterable) {\n          if (module.type && module.type.startsWith(\"webassembly\")) {\n            const filenameTemplate = outputOptions.webassemblyModuleFilename;\n            result.push({\n              render: () => this.renderWebAssembly(module, moduleTemplates.webassembly, dependencyTemplates),\n              filenameTemplate,\n              pathOptions: {\n                module\n              },\n              identifier: `webassemblyModule${module.id}`,\n              hash: module.hash\n            });\n          }\n        }\n        return result;\n      });\n      compilation.hooks.afterChunks.tap(\"WebAssemblyModulesPlugin\", () => {\n        const initialWasmModules = new Set();\n        for (const chunk of compilation.chunks) {\n          if (chunk.canBeInitial()) {\n            for (const module of chunk.modulesIterable) {\n              if (module.type.startsWith(\"webassembly\")) {\n                initialWasmModules.add(module);\n              }\n            }\n          }\n        }\n        for (const module of initialWasmModules) {\n          compilation.errors.push(new WebAssemblyInInitialChunkError(module, compilation.requestShortener));\n        }\n      });\n    });\n  }\n  renderWebAssembly(module, moduleTemplate, dependencyTemplates) {\n    return moduleTemplate.render(module, dependencyTemplates, {});\n  }\n}\nmodule.exports = WebAssemblyModulesPlugin;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}