{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\nconst asyncLib = require(\"neo-async\");\nconst SingleEntryDependency = require(\"./dependencies/SingleEntryDependency\");\nclass LibManifestPlugin {\n  constructor(options) {\n    this.options = options;\n  }\n  apply(compiler) {\n    compiler.hooks.emit.tapAsync(\"LibManifestPlugin\", (compilation, callback) => {\n      asyncLib.forEach(compilation.chunks, (chunk, callback) => {\n        if (!chunk.isOnlyInitial()) {\n          callback();\n          return;\n        }\n        const targetPath = compilation.getPath(this.options.path, {\n          hash: compilation.hash,\n          chunk\n        });\n        const name = this.options.name && compilation.getPath(this.options.name, {\n          hash: compilation.hash,\n          chunk\n        });\n        const manifest = {\n          name,\n          type: this.options.type,\n          content: Array.from(chunk.modulesIterable, module => {\n            if (this.options.entryOnly && !module.reasons.some(r => r.dependency instanceof SingleEntryDependency)) {\n              return;\n            }\n            if (module.libIdent) {\n              const ident = module.libIdent({\n                context: this.options.context || compiler.options.context\n              });\n              if (ident) {\n                return {\n                  ident,\n                  data: {\n                    id: module.id,\n                    buildMeta: module.buildMeta\n                  }\n                };\n              }\n            }\n          }).filter(Boolean).reduce((obj, item) => {\n            obj[item.ident] = item.data;\n            return obj;\n          }, Object.create(null))\n        };\n        // Apply formatting to content if format flag is true;\n        const manifestContent = this.options.format ? JSON.stringify(manifest, null, 2) : JSON.stringify(manifest);\n        const content = Buffer.from(manifestContent, \"utf8\");\n        compiler.outputFileSystem.mkdirp(path.dirname(targetPath), err => {\n          if (err) return callback(err);\n          compiler.outputFileSystem.writeFile(targetPath, content, callback);\n        });\n      }, callback);\n    });\n  }\n}\nmodule.exports = LibManifestPlugin;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}