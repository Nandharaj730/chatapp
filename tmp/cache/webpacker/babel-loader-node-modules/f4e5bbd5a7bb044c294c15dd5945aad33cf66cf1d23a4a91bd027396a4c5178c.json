{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Queue = require(\"./util/Queue\");\nconst addToSet = (a, b) => {\n  for (const item of b) {\n    a.add(item);\n  }\n};\nclass FlagDependencyExportsPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"FlagDependencyExportsPlugin\", compilation => {\n      compilation.hooks.finishModules.tap(\"FlagDependencyExportsPlugin\", modules => {\n        const dependencies = new Map();\n        const queue = new Queue();\n        let module;\n        let moduleWithExports;\n        let moduleProvidedExports;\n        let providedExportsAreTemporary;\n        const processDependenciesBlock = depBlock => {\n          for (const dep of depBlock.dependencies) {\n            if (processDependency(dep)) return true;\n          }\n          for (const variable of depBlock.variables) {\n            for (const dep of variable.dependencies) {\n              if (processDependency(dep)) return true;\n            }\n          }\n          for (const block of depBlock.blocks) {\n            if (processDependenciesBlock(block)) return true;\n          }\n          return false;\n        };\n        const processDependency = dep => {\n          const exportDesc = dep.getExports && dep.getExports();\n          if (!exportDesc) return;\n          moduleWithExports = true;\n          const exports = exportDesc.exports;\n          // break early if it's only in the worst state\n          if (module.buildMeta.providedExports === true) {\n            return true;\n          }\n          // break if it should move to the worst state\n          if (exports === true) {\n            module.buildMeta.providedExports = true;\n            return true;\n          }\n          // merge in new exports\n          if (Array.isArray(exports)) {\n            addToSet(moduleProvidedExports, exports);\n          }\n          // store dependencies\n          const exportDeps = exportDesc.dependencies;\n          if (exportDeps) {\n            providedExportsAreTemporary = true;\n            for (const exportDependency of exportDeps) {\n              // add dependency for this module\n              const set = dependencies.get(exportDependency);\n              if (set === undefined) {\n                dependencies.set(exportDependency, new Set([module]));\n              } else {\n                set.add(module);\n              }\n            }\n          }\n          return false;\n        };\n        const notifyDependencies = () => {\n          const deps = dependencies.get(module);\n          if (deps !== undefined) {\n            for (const dep of deps) {\n              queue.enqueue(dep);\n            }\n          }\n        };\n        const notifyDependenciesIfDifferent = (set, array) => {\n          const deps = dependencies.get(module);\n          if (deps !== undefined) {\n            if (set.size === array.length) {\n              let i = 0;\n              let different = false;\n              for (const item of set) {\n                if (item !== array[i++]) {\n                  different = true;\n                  break;\n                }\n              }\n              if (!different) return;\n            }\n            for (const dep of deps) {\n              queue.enqueue(dep);\n            }\n          }\n        };\n\n        // Start with all modules without provided exports\n        for (const module of modules) {\n          if (module.buildInfo.temporaryProvidedExports) {\n            // Clear exports when they are temporary\n            // and recreate them\n            module.buildMeta.providedExports = null;\n            queue.enqueue(module);\n          } else if (!module.buildMeta.providedExports) {\n            queue.enqueue(module);\n          }\n        }\n        while (queue.length > 0) {\n          module = queue.dequeue();\n          if (module.buildMeta.providedExports !== true) {\n            moduleWithExports = module.buildMeta && module.buildMeta.exportsType;\n            moduleProvidedExports = new Set();\n            providedExportsAreTemporary = false;\n            processDependenciesBlock(module);\n            module.buildInfo.temporaryProvidedExports = providedExportsAreTemporary;\n            if (!moduleWithExports) {\n              notifyDependencies();\n              module.buildMeta.providedExports = true;\n            } else if (module.buildMeta.providedExports === true) {\n              notifyDependencies();\n            } else if (!module.buildMeta.providedExports) {\n              notifyDependencies();\n              module.buildMeta.providedExports = Array.from(moduleProvidedExports);\n            } else {\n              notifyDependenciesIfDifferent(moduleProvidedExports, module.buildMeta.providedExports);\n              module.buildMeta.providedExports = Array.from(moduleProvidedExports);\n            }\n          }\n        }\n      });\n      const providedExportsCache = new WeakMap();\n      compilation.hooks.rebuildModule.tap(\"FlagDependencyExportsPlugin\", module => {\n        providedExportsCache.set(module, module.buildMeta.providedExports);\n      });\n      compilation.hooks.finishRebuildingModule.tap(\"FlagDependencyExportsPlugin\", module => {\n        module.buildMeta.providedExports = providedExportsCache.get(module);\n      });\n    });\n  }\n}\nmodule.exports = FlagDependencyExportsPlugin;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}