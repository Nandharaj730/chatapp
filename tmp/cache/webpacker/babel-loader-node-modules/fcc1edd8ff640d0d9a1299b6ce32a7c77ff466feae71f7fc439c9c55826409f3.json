{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Naoyuki Kanezawa @nkzawa\n*/\n\"use strict\";\n\nconst MultiEntryDependency = require(\"./dependencies/MultiEntryDependency\");\nconst SingleEntryDependency = require(\"./dependencies/SingleEntryDependency\");\nconst MultiModuleFactory = require(\"./MultiModuleFactory\");\nconst MultiEntryPlugin = require(\"./MultiEntryPlugin\");\nconst SingleEntryPlugin = require(\"./SingleEntryPlugin\");\n\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryDynamic} EntryDynamic */\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryStatic} EntryStatic */\n/** @typedef {import(\"./Compiler\")} Compiler */\n\nclass DynamicEntryPlugin {\n  /**\n   * @param {string} context the context path\n   * @param {EntryDynamic} entry the entry value\n   */\n  constructor(context, entry) {\n    this.context = context;\n    this.entry = entry;\n  }\n\n  /**\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"DynamicEntryPlugin\", (compilation, _ref) => {\n      let normalModuleFactory = _ref.normalModuleFactory;\n      const multiModuleFactory = new MultiModuleFactory();\n      compilation.dependencyFactories.set(MultiEntryDependency, multiModuleFactory);\n      compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);\n    });\n    compiler.hooks.make.tapAsync(\"DynamicEntryPlugin\", (compilation, callback) => {\n      /**\n       * @param {string|string[]} entry entry value or array of entry values\n       * @param {string} name name of entry\n       * @returns {Promise<EntryStatic>} returns the promise resolving the Compilation#addEntry function\n       */\n      const addEntry = (entry, name) => {\n        const dep = DynamicEntryPlugin.createDependency(entry, name);\n        return new Promise((resolve, reject) => {\n          compilation.addEntry(this.context, dep, name, err => {\n            if (err) return reject(err);\n            resolve();\n          });\n        });\n      };\n      Promise.resolve(this.entry()).then(entry => {\n        if (typeof entry === \"string\" || Array.isArray(entry)) {\n          addEntry(entry, \"main\").then(() => callback(), callback);\n        } else if (typeof entry === \"object\") {\n          Promise.all(Object.keys(entry).map(name => {\n            return addEntry(entry[name], name);\n          })).then(() => callback(), callback);\n        }\n      });\n    });\n  }\n}\nmodule.exports = DynamicEntryPlugin;\n/**\n * @param {string|string[]} entry entry value or array of entry paths\n * @param {string} name name of entry\n * @returns {SingleEntryDependency|MultiEntryDependency} returns dep\n */\nDynamicEntryPlugin.createDependency = (entry, name) => {\n  if (Array.isArray(entry)) {\n    return MultiEntryPlugin.createDependency(entry, name);\n  } else {\n    return SingleEntryPlugin.createDependency(entry, name);\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}