{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../schemas/plugins/ProgressPlugin.json\");\n\n/** @typedef {import(\"../declarations/plugins/ProgressPlugin\").ProgressPluginArgument} ProgressPluginArgument */\n/** @typedef {import(\"../declarations/plugins/ProgressPlugin\").ProgressPluginOptions} ProgressPluginOptions */\n\nconst createDefaultHandler = (profile, logger) => {\n  let lastState;\n  let lastStateTime;\n  const defaultHandler = function (percentage, msg) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    logger.status(`${Math.floor(percentage * 100)}%`, msg, ...args);\n    if (profile) {\n      let state = msg;\n      state = state.replace(/^\\d+\\/\\d+\\s+/, \"\");\n      if (percentage === 0) {\n        lastState = null;\n        lastStateTime = Date.now();\n      } else if (state !== lastState || percentage === 1) {\n        const now = Date.now();\n        if (lastState) {\n          const diff = now - lastStateTime;\n          const stateMsg = `${diff}ms ${lastState}`;\n          if (diff > 1000) {\n            logger.warn(stateMsg);\n          } else if (diff > 10) {\n            logger.info(stateMsg);\n          } else if (diff > 0) {\n            logger.log(stateMsg);\n          } else {\n            logger.debug(stateMsg);\n          }\n        }\n        lastState = state;\n        lastStateTime = now;\n      }\n    }\n    if (percentage === 1) logger.status();\n  };\n  return defaultHandler;\n};\nclass ProgressPlugin {\n  /**\n   * @param {ProgressPluginArgument} options options\n   */\n  constructor(options) {\n    if (typeof options === \"function\") {\n      options = {\n        handler: options\n      };\n    }\n    options = options || {};\n    validateOptions(schema, options, \"Progress Plugin\");\n    options = Object.assign({}, ProgressPlugin.defaultOptions, options);\n    this.profile = options.profile;\n    this.handler = options.handler;\n    this.modulesCount = options.modulesCount;\n    this.showEntries = options.entries;\n    this.showModules = options.modules;\n    this.showActiveModules = options.activeModules;\n  }\n  apply(compiler) {\n    const modulesCount = this.modulesCount;\n    const handler = this.handler || createDefaultHandler(this.profile, compiler.getInfrastructureLogger(\"webpack.Progress\"));\n    const showEntries = this.showEntries;\n    const showModules = this.showModules;\n    const showActiveModules = this.showActiveModules;\n    if (compiler.compilers) {\n      const states = new Array(compiler.compilers.length);\n      compiler.compilers.forEach((compiler, idx) => {\n        new ProgressPlugin(function (p, msg) {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n            args[_key2 - 2] = arguments[_key2];\n          }\n          states[idx] = [p, msg, ...args];\n          handler(states.map(state => state && state[0] || 0).reduce((a, b) => a + b) / states.length, `[${idx}] ${msg}`, ...args);\n        }).apply(compiler);\n      });\n    } else {\n      let lastModulesCount = 0;\n      let lastEntriesCount = 0;\n      let moduleCount = modulesCount;\n      let entriesCount = 1;\n      let doneModules = 0;\n      let doneEntries = 0;\n      const activeModules = new Set();\n      let lastActiveModule = \"\";\n      const update = () => {\n        const percentByModules = doneModules / Math.max(lastModulesCount, moduleCount);\n        const percentByEntries = doneEntries / Math.max(lastEntriesCount, entriesCount);\n        const items = [0.1 + Math.max(percentByModules, percentByEntries) * 0.6, \"building\"];\n        if (showEntries) {\n          items.push(`${doneEntries}/${entriesCount} entries`);\n        }\n        if (showModules) {\n          items.push(`${doneModules}/${moduleCount} modules`);\n        }\n        if (showActiveModules) {\n          items.push(`${activeModules.size} active`);\n          items.push(lastActiveModule);\n        }\n        handler(...items);\n      };\n      const moduleAdd = module => {\n        moduleCount++;\n        if (showActiveModules) {\n          const ident = module.identifier();\n          if (ident) {\n            activeModules.add(ident);\n            lastActiveModule = ident;\n          }\n        }\n        update();\n      };\n      const entryAdd = (entry, name) => {\n        entriesCount++;\n        update();\n      };\n      const moduleDone = module => {\n        doneModules++;\n        if (showActiveModules) {\n          const ident = module.identifier();\n          if (ident) {\n            activeModules.delete(ident);\n            if (lastActiveModule === ident) {\n              lastActiveModule = \"\";\n              for (const m of activeModules) {\n                lastActiveModule = m;\n              }\n            }\n          }\n        }\n        update();\n      };\n      const entryDone = (entry, name) => {\n        doneEntries++;\n        update();\n      };\n      compiler.hooks.compilation.tap(\"ProgressPlugin\", compilation => {\n        if (compilation.compiler.isChild()) return;\n        lastModulesCount = moduleCount;\n        lastEntriesCount = entriesCount;\n        moduleCount = entriesCount = 0;\n        doneModules = doneEntries = 0;\n        handler(0, \"compiling\");\n        compilation.hooks.buildModule.tap(\"ProgressPlugin\", moduleAdd);\n        compilation.hooks.failedModule.tap(\"ProgressPlugin\", moduleDone);\n        compilation.hooks.succeedModule.tap(\"ProgressPlugin\", moduleDone);\n        compilation.hooks.addEntry.tap(\"ProgressPlugin\", entryAdd);\n        compilation.hooks.failedEntry.tap(\"ProgressPlugin\", entryDone);\n        compilation.hooks.succeedEntry.tap(\"ProgressPlugin\", entryDone);\n        const hooks = {\n          finishModules: \"finish module graph\",\n          seal: \"sealing\",\n          beforeChunks: \"chunk graph\",\n          afterChunks: \"after chunk graph\",\n          optimizeDependenciesBasic: \"basic dependencies optimization\",\n          optimizeDependencies: \"dependencies optimization\",\n          optimizeDependenciesAdvanced: \"advanced dependencies optimization\",\n          afterOptimizeDependencies: \"after dependencies optimization\",\n          optimize: \"optimizing\",\n          optimizeModulesBasic: \"basic module optimization\",\n          optimizeModules: \"module optimization\",\n          optimizeModulesAdvanced: \"advanced module optimization\",\n          afterOptimizeModules: \"after module optimization\",\n          optimizeChunksBasic: \"basic chunk optimization\",\n          optimizeChunks: \"chunk optimization\",\n          optimizeChunksAdvanced: \"advanced chunk optimization\",\n          afterOptimizeChunks: \"after chunk optimization\",\n          optimizeTree: \"module and chunk tree optimization\",\n          afterOptimizeTree: \"after module and chunk tree optimization\",\n          optimizeChunkModulesBasic: \"basic chunk modules optimization\",\n          optimizeChunkModules: \"chunk modules optimization\",\n          optimizeChunkModulesAdvanced: \"advanced chunk modules optimization\",\n          afterOptimizeChunkModules: \"after chunk modules optimization\",\n          reviveModules: \"module reviving\",\n          optimizeModuleOrder: \"module order optimization\",\n          advancedOptimizeModuleOrder: \"advanced module order optimization\",\n          beforeModuleIds: \"before module ids\",\n          moduleIds: \"module ids\",\n          optimizeModuleIds: \"module id optimization\",\n          afterOptimizeModuleIds: \"module id optimization\",\n          reviveChunks: \"chunk reviving\",\n          optimizeChunkOrder: \"chunk order optimization\",\n          beforeChunkIds: \"before chunk ids\",\n          optimizeChunkIds: \"chunk id optimization\",\n          afterOptimizeChunkIds: \"after chunk id optimization\",\n          recordModules: \"record modules\",\n          recordChunks: \"record chunks\",\n          beforeHash: \"hashing\",\n          afterHash: \"after hashing\",\n          recordHash: \"record hash\",\n          beforeModuleAssets: \"module assets processing\",\n          beforeChunkAssets: \"chunk assets processing\",\n          additionalChunkAssets: \"additional chunk assets processing\",\n          record: \"recording\",\n          additionalAssets: \"additional asset processing\",\n          optimizeChunkAssets: \"chunk asset optimization\",\n          afterOptimizeChunkAssets: \"after chunk asset optimization\",\n          optimizeAssets: \"asset optimization\",\n          afterOptimizeAssets: \"after asset optimization\",\n          afterSeal: \"after seal\"\n        };\n        const numberOfHooks = Object.keys(hooks).length;\n        Object.keys(hooks).forEach((name, idx) => {\n          const title = hooks[name];\n          const percentage = idx / numberOfHooks * 0.25 + 0.7;\n          compilation.hooks[name].intercept({\n            name: \"ProgressPlugin\",\n            context: true,\n            call: () => {\n              handler(percentage, title);\n            },\n            tap: (context, tap) => {\n              if (context) {\n                // p is percentage from 0 to 1\n                // args is any number of messages in a hierarchical matter\n                context.reportProgress = function (p) {\n                  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n                    args[_key3 - 1] = arguments[_key3];\n                  }\n                  handler(percentage, title, tap.name, ...args);\n                };\n              }\n              handler(percentage, title, tap.name);\n            }\n          });\n        });\n      });\n      compiler.hooks.emit.intercept({\n        name: \"ProgressPlugin\",\n        context: true,\n        call: () => {\n          handler(0.95, \"emitting\");\n        },\n        tap: (context, tap) => {\n          if (context) {\n            context.reportProgress = function (p) {\n              for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n                args[_key4 - 1] = arguments[_key4];\n              }\n              handler(0.95, \"emitting\", tap.name, ...args);\n            };\n          }\n          handler(0.95, \"emitting\", tap.name);\n        }\n      });\n      compiler.hooks.afterEmit.intercept({\n        name: \"ProgressPlugin\",\n        context: true,\n        call: () => {\n          handler(0.98, \"after emitting\");\n        },\n        tap: (context, tap) => {\n          if (context) {\n            context.reportProgress = function (p) {\n              for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                args[_key5 - 1] = arguments[_key5];\n              }\n              handler(0.98, \"after emitting\", tap.name, ...args);\n            };\n          }\n          handler(0.98, \"after emitting\", tap.name);\n        }\n      });\n      compiler.hooks.done.tap(\"ProgressPlugin\", () => {\n        handler(1, \"\");\n      });\n    }\n  }\n}\nProgressPlugin.defaultOptions = {\n  profile: false,\n  modulesCount: 500,\n  modules: true,\n  activeModules: true,\n  // TODO webpack 5 default this to true\n  entries: false\n};\nmodule.exports = ProgressPlugin;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}