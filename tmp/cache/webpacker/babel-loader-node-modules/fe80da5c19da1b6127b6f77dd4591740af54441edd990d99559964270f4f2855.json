{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nconst _require = require(\"tapable\"),\n  Tapable = _require.Tapable,\n  HookMap = _require.HookMap,\n  SyncHook = _require.SyncHook,\n  SyncWaterfallHook = _require.SyncWaterfallHook;\nconst Factory = require(\"enhanced-resolve\").ResolverFactory;\nconst _require2 = require(\"./util/cleverMerge\"),\n  cachedCleverMerge = _require2.cachedCleverMerge;\n\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n\nconst EMTPY_RESOLVE_OPTIONS = {};\nmodule.exports = class ResolverFactory extends Tapable {\n  constructor() {\n    super();\n    this.hooks = {\n      resolveOptions: new HookMap(() => new SyncWaterfallHook([\"resolveOptions\"])),\n      resolver: new HookMap(() => new SyncHook([\"resolver\", \"resolveOptions\"]))\n    };\n    this._pluginCompat.tap(\"ResolverFactory\", options => {\n      let match;\n      match = /^resolve-options (.+)$/.exec(options.name);\n      if (match) {\n        this.hooks.resolveOptions.for(match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n        return true;\n      }\n      match = /^resolver (.+)$/.exec(options.name);\n      if (match) {\n        this.hooks.resolver.for(match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n        return true;\n      }\n    });\n    this.cache2 = new Map();\n  }\n  get(type, resolveOptions) {\n    resolveOptions = resolveOptions || EMTPY_RESOLVE_OPTIONS;\n    const ident = `${type}|${JSON.stringify(resolveOptions)}`;\n    const resolver = this.cache2.get(ident);\n    if (resolver) return resolver;\n    const newResolver = this._create(type, resolveOptions);\n    this.cache2.set(ident, newResolver);\n    return newResolver;\n  }\n  _create(type, resolveOptions) {\n    const originalResolveOptions = Object.assign({}, resolveOptions);\n    resolveOptions = this.hooks.resolveOptions.for(type).call(resolveOptions);\n    const resolver = Factory.createResolver(resolveOptions);\n    if (!resolver) {\n      throw new Error(\"No resolver created\");\n    }\n    /** @type {Map<Object, Resolver>} */\n    const childCache = new Map();\n    resolver.withOptions = options => {\n      const cacheEntry = childCache.get(options);\n      if (cacheEntry !== undefined) return cacheEntry;\n      const mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n      const resolver = this.get(type, mergedOptions);\n      childCache.set(options, resolver);\n      return resolver;\n    };\n    this.hooks.resolver.for(type).call(resolver, resolveOptions);\n    return resolver;\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}