{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"../util/identifier\");\nconst _require = require(\"../util/SetHelpers\"),\n  intersect = _require.intersect;\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n\nconst moveModuleBetween = (oldChunk, newChunk) => {\n  return module => {\n    oldChunk.moveModule(module, newChunk);\n  };\n};\nconst isNotAEntryModule = entryModule => {\n  return module => {\n    return entryModule !== module;\n  };\n};\nclass AggressiveSplittingPlugin {\n  /**\n   * @param {AggressiveSplittingPluginOptions=} options options object\n   */\n  constructor(options) {\n    if (!options) options = {};\n    validateOptions(schema, options, \"Aggressive Splitting Plugin\");\n    this.options = options;\n    if (typeof this.options.minSize !== \"number\") {\n      this.options.minSize = 30 * 1024;\n    }\n    if (typeof this.options.maxSize !== \"number\") {\n      this.options.maxSize = 50 * 1024;\n    }\n    if (typeof this.options.chunkOverhead !== \"number\") {\n      this.options.chunkOverhead = 0;\n    }\n    if (typeof this.options.entryChunkMultiplicator !== \"number\") {\n      this.options.entryChunkMultiplicator = 1;\n    }\n  }\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(\"AggressiveSplittingPlugin\", compilation => {\n      let needAdditionalSeal = false;\n      let newSplits;\n      let fromAggressiveSplittingSet;\n      let chunkSplitDataMap;\n      compilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n        newSplits = [];\n        fromAggressiveSplittingSet = new Set();\n        chunkSplitDataMap = new Map();\n      });\n      compilation.hooks.optimizeChunksAdvanced.tap(\"AggressiveSplittingPlugin\", chunks => {\n        // Precompute stuff\n        const nameToModuleMap = new Map();\n        const moduleToNameMap = new Map();\n        for (const m of compilation.modules) {\n          const name = identifierUtils.makePathsRelative(compiler.context, m.identifier(), compilation.cache);\n          nameToModuleMap.set(name, m);\n          moduleToNameMap.set(m, name);\n        }\n\n        // Check used chunk ids\n        const usedIds = new Set();\n        for (const chunk of chunks) {\n          usedIds.add(chunk.id);\n        }\n        const recordedSplits = compilation.records && compilation.records.aggressiveSplits || [];\n        const usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits;\n        const minSize = this.options.minSize;\n        const maxSize = this.options.maxSize;\n        const applySplit = splitData => {\n          // Cannot split if id is already taken\n          if (splitData.id !== undefined && usedIds.has(splitData.id)) {\n            return false;\n          }\n\n          // Get module objects from names\n          const selectedModules = splitData.modules.map(name => nameToModuleMap.get(name));\n\n          // Does the modules exist at all?\n          if (!selectedModules.every(Boolean)) return false;\n\n          // Check if size matches (faster than waiting for hash)\n          const size = selectedModules.reduce((sum, m) => sum + m.size(), 0);\n          if (size !== splitData.size) return false;\n\n          // get chunks with all modules\n          const selectedChunks = intersect(selectedModules.map(m => new Set(m.chunksIterable)));\n\n          // No relevant chunks found\n          if (selectedChunks.size === 0) return false;\n\n          // The found chunk is already the split or similar\n          if (selectedChunks.size === 1 && Array.from(selectedChunks)[0].getNumberOfModules() === selectedModules.length) {\n            const chunk = Array.from(selectedChunks)[0];\n            if (fromAggressiveSplittingSet.has(chunk)) return false;\n            fromAggressiveSplittingSet.add(chunk);\n            chunkSplitDataMap.set(chunk, splitData);\n            return true;\n          }\n\n          // split the chunk into two parts\n          const newChunk = compilation.addChunk();\n          newChunk.chunkReason = \"aggressive splitted\";\n          for (const chunk of selectedChunks) {\n            selectedModules.forEach(moveModuleBetween(chunk, newChunk));\n            chunk.split(newChunk);\n            chunk.name = null;\n          }\n          fromAggressiveSplittingSet.add(newChunk);\n          chunkSplitDataMap.set(newChunk, splitData);\n          if (splitData.id !== null && splitData.id !== undefined) {\n            newChunk.id = splitData.id;\n          }\n          return true;\n        };\n\n        // try to restore to recorded splitting\n        let changed = false;\n        for (let j = 0; j < usedSplits.length; j++) {\n          const splitData = usedSplits[j];\n          if (applySplit(splitData)) changed = true;\n        }\n\n        // for any chunk which isn't splitted yet, split it and create a new entry\n        // start with the biggest chunk\n        const sortedChunks = chunks.slice().sort((a, b) => {\n          const diff1 = b.modulesSize() - a.modulesSize();\n          if (diff1) return diff1;\n          const diff2 = a.getNumberOfModules() - b.getNumberOfModules();\n          if (diff2) return diff2;\n          const modulesA = Array.from(a.modulesIterable);\n          const modulesB = Array.from(b.modulesIterable);\n          modulesA.sort();\n          modulesB.sort();\n          const aI = modulesA[Symbol.iterator]();\n          const bI = modulesB[Symbol.iterator]();\n          // eslint-disable-next-line no-constant-condition\n          while (true) {\n            const aItem = aI.next();\n            const bItem = bI.next();\n            if (aItem.done) return 0;\n            const aModuleIdentifier = aItem.value.identifier();\n            const bModuleIdentifier = bItem.value.identifier();\n            if (aModuleIdentifier > bModuleIdentifier) return -1;\n            if (aModuleIdentifier < bModuleIdentifier) return 1;\n          }\n        });\n        for (const chunk of sortedChunks) {\n          if (fromAggressiveSplittingSet.has(chunk)) continue;\n          const size = chunk.modulesSize();\n          if (size > maxSize && chunk.getNumberOfModules() > 1) {\n            const modules = chunk.getModules().filter(isNotAEntryModule(chunk.entryModule)).sort((a, b) => {\n              a = a.identifier();\n              b = b.identifier();\n              if (a > b) return 1;\n              if (a < b) return -1;\n              return 0;\n            });\n            const selectedModules = [];\n            let selectedModulesSize = 0;\n            for (let k = 0; k < modules.length; k++) {\n              const module = modules[k];\n              const newSize = selectedModulesSize + module.size();\n              if (newSize > maxSize && selectedModulesSize >= minSize) {\n                break;\n              }\n              selectedModulesSize = newSize;\n              selectedModules.push(module);\n            }\n            if (selectedModules.length === 0) continue;\n            const splitData = {\n              modules: selectedModules.map(m => moduleToNameMap.get(m)).sort(),\n              size: selectedModulesSize\n            };\n            if (applySplit(splitData)) {\n              newSplits = (newSplits || []).concat(splitData);\n              changed = true;\n            }\n          }\n        }\n        if (changed) return true;\n      });\n      compilation.hooks.recordHash.tap(\"AggressiveSplittingPlugin\", records => {\n        // 4. save made splittings to records\n        const allSplits = new Set();\n        const invalidSplits = new Set();\n\n        // Check if some splittings are invalid\n        // We remove invalid splittings and try again\n        for (const chunk of compilation.chunks) {\n          const splitData = chunkSplitDataMap.get(chunk);\n          if (splitData !== undefined) {\n            if (splitData.hash && chunk.hash !== splitData.hash) {\n              // Split was successful, but hash doesn't equal\n              // We can throw away the split since it's useless now\n              invalidSplits.add(splitData);\n            }\n          }\n        }\n        if (invalidSplits.size > 0) {\n          records.aggressiveSplits = records.aggressiveSplits.filter(splitData => !invalidSplits.has(splitData));\n          needAdditionalSeal = true;\n        } else {\n          // set hash and id values on all (new) splittings\n          for (const chunk of compilation.chunks) {\n            const splitData = chunkSplitDataMap.get(chunk);\n            if (splitData !== undefined) {\n              splitData.hash = chunk.hash;\n              splitData.id = chunk.id;\n              allSplits.add(splitData);\n              // set flag for stats\n              chunk.recorded = true;\n            }\n          }\n\n          // Also add all unused historial splits (after the used ones)\n          // They can still be used in some future compilation\n          const recordedSplits = compilation.records && compilation.records.aggressiveSplits;\n          if (recordedSplits) {\n            for (const splitData of recordedSplits) {\n              if (!invalidSplits.has(splitData)) allSplits.add(splitData);\n            }\n          }\n\n          // record all splits\n          records.aggressiveSplits = Array.from(allSplits);\n          needAdditionalSeal = false;\n        }\n      });\n      compilation.hooks.needAdditionalSeal.tap(\"AggressiveSplittingPlugin\", () => {\n        if (needAdditionalSeal) {\n          needAdditionalSeal = false;\n          return true;\n        }\n      });\n    });\n  }\n}\nmodule.exports = AggressiveSplittingPlugin;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}