{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst OptionsApply = require(\"./OptionsApply\");\nconst JavascriptModulesPlugin = require(\"./JavascriptModulesPlugin\");\nconst JsonModulesPlugin = require(\"./JsonModulesPlugin\");\nconst WebAssemblyModulesPlugin = require(\"./wasm/WebAssemblyModulesPlugin\");\nconst LoaderTargetPlugin = require(\"./LoaderTargetPlugin\");\nconst FunctionModulePlugin = require(\"./FunctionModulePlugin\");\nconst EvalDevToolModulePlugin = require(\"./EvalDevToolModulePlugin\");\nconst SourceMapDevToolPlugin = require(\"./SourceMapDevToolPlugin\");\nconst EvalSourceMapDevToolPlugin = require(\"./EvalSourceMapDevToolPlugin\");\nconst EntryOptionPlugin = require(\"./EntryOptionPlugin\");\nconst RecordIdsPlugin = require(\"./RecordIdsPlugin\");\nconst APIPlugin = require(\"./APIPlugin\");\nconst ConstPlugin = require(\"./ConstPlugin\");\nconst CommonJsStuffPlugin = require(\"./CommonJsStuffPlugin\");\nconst CompatibilityPlugin = require(\"./CompatibilityPlugin\");\nconst TemplatedPathPlugin = require(\"./TemplatedPathPlugin\");\nconst WarnCaseSensitiveModulesPlugin = require(\"./WarnCaseSensitiveModulesPlugin\");\nconst UseStrictPlugin = require(\"./UseStrictPlugin\");\nconst LoaderPlugin = require(\"./dependencies/LoaderPlugin\");\nconst CommonJsPlugin = require(\"./dependencies/CommonJsPlugin\");\nconst HarmonyModulesPlugin = require(\"./dependencies/HarmonyModulesPlugin\");\nconst SystemPlugin = require(\"./dependencies/SystemPlugin\");\nconst ImportPlugin = require(\"./dependencies/ImportPlugin\");\nconst RequireContextPlugin = require(\"./dependencies/RequireContextPlugin\");\nconst RequireEnsurePlugin = require(\"./dependencies/RequireEnsurePlugin\");\nconst RequireIncludePlugin = require(\"./dependencies/RequireIncludePlugin\");\nconst _require = require(\"./util/cleverMerge\"),\n  cachedCleverMerge = _require.cachedCleverMerge;\n\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptions} WebpackOptions */\n/** @typedef {import(\"./Compiler\")} Compiler */\n\nclass WebpackOptionsApply extends OptionsApply {\n  constructor() {\n    super();\n  }\n\n  /**\n   * @param {WebpackOptions} options options object\n   * @param {Compiler} compiler compiler object\n   * @returns {WebpackOptions} options object\n   */\n  process(options, compiler) {\n    let ExternalsPlugin;\n    compiler.outputPath = options.output.path;\n    compiler.recordsInputPath = options.recordsInputPath || options.recordsPath;\n    compiler.recordsOutputPath = options.recordsOutputPath || options.recordsPath;\n    compiler.name = options.name;\n    // TODO webpack 5 refactor this to MultiCompiler.setDependencies() with a WeakMap\n    // @ts-ignore TODO\n    compiler.dependencies = options.dependencies;\n    if (typeof options.target === \"string\") {\n      let JsonpTemplatePlugin;\n      let FetchCompileWasmTemplatePlugin;\n      let ReadFileCompileWasmTemplatePlugin;\n      let NodeSourcePlugin;\n      let NodeTargetPlugin;\n      let NodeTemplatePlugin;\n      switch (options.target) {\n        case \"web\":\n          JsonpTemplatePlugin = require(\"./web/JsonpTemplatePlugin\");\n          FetchCompileWasmTemplatePlugin = require(\"./web/FetchCompileWasmTemplatePlugin\");\n          NodeSourcePlugin = require(\"./node/NodeSourcePlugin\");\n          new JsonpTemplatePlugin().apply(compiler);\n          new FetchCompileWasmTemplatePlugin({\n            mangleImports: options.optimization.mangleWasmImports\n          }).apply(compiler);\n          new FunctionModulePlugin().apply(compiler);\n          new NodeSourcePlugin(options.node).apply(compiler);\n          new LoaderTargetPlugin(options.target).apply(compiler);\n          break;\n        case \"webworker\":\n          {\n            let WebWorkerTemplatePlugin = require(\"./webworker/WebWorkerTemplatePlugin\");\n            FetchCompileWasmTemplatePlugin = require(\"./web/FetchCompileWasmTemplatePlugin\");\n            NodeSourcePlugin = require(\"./node/NodeSourcePlugin\");\n            new WebWorkerTemplatePlugin().apply(compiler);\n            new FetchCompileWasmTemplatePlugin({\n              mangleImports: options.optimization.mangleWasmImports\n            }).apply(compiler);\n            new FunctionModulePlugin().apply(compiler);\n            new NodeSourcePlugin(options.node).apply(compiler);\n            new LoaderTargetPlugin(options.target).apply(compiler);\n            break;\n          }\n        case \"node\":\n        case \"async-node\":\n          NodeTemplatePlugin = require(\"./node/NodeTemplatePlugin\");\n          ReadFileCompileWasmTemplatePlugin = require(\"./node/ReadFileCompileWasmTemplatePlugin\");\n          NodeTargetPlugin = require(\"./node/NodeTargetPlugin\");\n          new NodeTemplatePlugin({\n            asyncChunkLoading: options.target === \"async-node\"\n          }).apply(compiler);\n          new ReadFileCompileWasmTemplatePlugin({\n            mangleImports: options.optimization.mangleWasmImports\n          }).apply(compiler);\n          new FunctionModulePlugin().apply(compiler);\n          new NodeTargetPlugin().apply(compiler);\n          new LoaderTargetPlugin(\"node\").apply(compiler);\n          break;\n        case \"node-webkit\":\n          JsonpTemplatePlugin = require(\"./web/JsonpTemplatePlugin\");\n          NodeTargetPlugin = require(\"./node/NodeTargetPlugin\");\n          ExternalsPlugin = require(\"./ExternalsPlugin\");\n          new JsonpTemplatePlugin().apply(compiler);\n          new FunctionModulePlugin().apply(compiler);\n          new NodeTargetPlugin().apply(compiler);\n          new ExternalsPlugin(\"commonjs\", \"nw.gui\").apply(compiler);\n          new LoaderTargetPlugin(options.target).apply(compiler);\n          break;\n        case \"electron-main\":\n          NodeTemplatePlugin = require(\"./node/NodeTemplatePlugin\");\n          NodeTargetPlugin = require(\"./node/NodeTargetPlugin\");\n          ExternalsPlugin = require(\"./ExternalsPlugin\");\n          new NodeTemplatePlugin({\n            asyncChunkLoading: true\n          }).apply(compiler);\n          new FunctionModulePlugin().apply(compiler);\n          new NodeTargetPlugin().apply(compiler);\n          new ExternalsPlugin(\"commonjs\", [\"app\", \"auto-updater\", \"browser-window\", \"clipboard\", \"content-tracing\", \"crash-reporter\", \"dialog\", \"electron\", \"global-shortcut\", \"ipc\", \"ipc-main\", \"menu\", \"menu-item\", \"native-image\", \"original-fs\", \"power-monitor\", \"power-save-blocker\", \"protocol\", \"screen\", \"session\", \"shell\", \"tray\", \"web-contents\"]).apply(compiler);\n          new LoaderTargetPlugin(options.target).apply(compiler);\n          break;\n        case \"electron-renderer\":\n        case \"electron-preload\":\n          FetchCompileWasmTemplatePlugin = require(\"./web/FetchCompileWasmTemplatePlugin\");\n          NodeTargetPlugin = require(\"./node/NodeTargetPlugin\");\n          ExternalsPlugin = require(\"./ExternalsPlugin\");\n          if (options.target === \"electron-renderer\") {\n            JsonpTemplatePlugin = require(\"./web/JsonpTemplatePlugin\");\n            new JsonpTemplatePlugin().apply(compiler);\n          } else if (options.target === \"electron-preload\") {\n            NodeTemplatePlugin = require(\"./node/NodeTemplatePlugin\");\n            new NodeTemplatePlugin({\n              asyncChunkLoading: true\n            }).apply(compiler);\n          }\n          new FetchCompileWasmTemplatePlugin({\n            mangleImports: options.optimization.mangleWasmImports\n          }).apply(compiler);\n          new FunctionModulePlugin().apply(compiler);\n          new NodeTargetPlugin().apply(compiler);\n          new ExternalsPlugin(\"commonjs\", [\"clipboard\", \"crash-reporter\", \"desktop-capturer\", \"electron\", \"ipc\", \"ipc-renderer\", \"native-image\", \"original-fs\", \"remote\", \"screen\", \"shell\", \"web-frame\"]).apply(compiler);\n          new LoaderTargetPlugin(options.target).apply(compiler);\n          break;\n        default:\n          throw new Error(\"Unsupported target '\" + options.target + \"'.\");\n      }\n    }\n    // @ts-ignore This is always true, which is good this way\n    else if (options.target !== false) {\n      options.target(compiler);\n    } else {\n      throw new Error(\"Unsupported target '\" + options.target + \"'.\");\n    }\n    if (options.output.library || options.output.libraryTarget !== \"var\") {\n      const LibraryTemplatePlugin = require(\"./LibraryTemplatePlugin\");\n      new LibraryTemplatePlugin(options.output.library, options.output.libraryTarget, options.output.umdNamedDefine, options.output.auxiliaryComment || \"\", options.output.libraryExport).apply(compiler);\n    }\n    if (options.externals) {\n      ExternalsPlugin = require(\"./ExternalsPlugin\");\n      new ExternalsPlugin(options.output.libraryTarget, options.externals).apply(compiler);\n    }\n    let noSources;\n    let legacy;\n    let modern;\n    let comment;\n    if (options.devtool && (options.devtool.includes(\"sourcemap\") || options.devtool.includes(\"source-map\"))) {\n      const hidden = options.devtool.includes(\"hidden\");\n      const inline = options.devtool.includes(\"inline\");\n      const evalWrapped = options.devtool.includes(\"eval\");\n      const cheap = options.devtool.includes(\"cheap\");\n      const moduleMaps = options.devtool.includes(\"module\");\n      noSources = options.devtool.includes(\"nosources\");\n      legacy = options.devtool.includes(\"@\");\n      modern = options.devtool.includes(\"#\");\n      comment = legacy && modern ? \"\\n/*\\n//@ source\" + \"MappingURL=[url]\\n//# source\" + \"MappingURL=[url]\\n*/\" : legacy ? \"\\n/*\\n//@ source\" + \"MappingURL=[url]\\n*/\" : modern ? \"\\n//# source\" + \"MappingURL=[url]\" : null;\n      const Plugin = evalWrapped ? EvalSourceMapDevToolPlugin : SourceMapDevToolPlugin;\n      new Plugin({\n        filename: inline ? null : options.output.sourceMapFilename,\n        moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,\n        fallbackModuleFilenameTemplate: options.output.devtoolFallbackModuleFilenameTemplate,\n        append: hidden ? false : comment,\n        module: moduleMaps ? true : cheap ? false : true,\n        columns: cheap ? false : true,\n        lineToLine: options.output.devtoolLineToLine,\n        noSources: noSources,\n        namespace: options.output.devtoolNamespace\n      }).apply(compiler);\n    } else if (options.devtool && options.devtool.includes(\"eval\")) {\n      legacy = options.devtool.includes(\"@\");\n      modern = options.devtool.includes(\"#\");\n      comment = legacy && modern ? \"\\n//@ sourceURL=[url]\\n//# sourceURL=[url]\" : legacy ? \"\\n//@ sourceURL=[url]\" : modern ? \"\\n//# sourceURL=[url]\" : null;\n      new EvalDevToolModulePlugin({\n        sourceUrlComment: comment,\n        moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,\n        namespace: options.output.devtoolNamespace\n      }).apply(compiler);\n    }\n    new JavascriptModulesPlugin().apply(compiler);\n    new JsonModulesPlugin().apply(compiler);\n    new WebAssemblyModulesPlugin({\n      mangleImports: options.optimization.mangleWasmImports\n    }).apply(compiler);\n    new EntryOptionPlugin().apply(compiler);\n    compiler.hooks.entryOption.call(options.context, options.entry);\n    new CompatibilityPlugin().apply(compiler);\n    new HarmonyModulesPlugin(options.module).apply(compiler);\n    if (options.amd !== false) {\n      const AMDPlugin = require(\"./dependencies/AMDPlugin\");\n      const RequireJsStuffPlugin = require(\"./RequireJsStuffPlugin\");\n      new AMDPlugin(options.module, options.amd || {}).apply(compiler);\n      new RequireJsStuffPlugin().apply(compiler);\n    }\n    new CommonJsPlugin(options.module).apply(compiler);\n    new LoaderPlugin().apply(compiler);\n    if (options.node !== false) {\n      const NodeStuffPlugin = require(\"./NodeStuffPlugin\");\n      new NodeStuffPlugin(options.node).apply(compiler);\n    }\n    new CommonJsStuffPlugin().apply(compiler);\n    new APIPlugin().apply(compiler);\n    new ConstPlugin().apply(compiler);\n    new UseStrictPlugin().apply(compiler);\n    new RequireIncludePlugin().apply(compiler);\n    new RequireEnsurePlugin().apply(compiler);\n    new RequireContextPlugin(options.resolve.modules, options.resolve.extensions, options.resolve.mainFiles).apply(compiler);\n    new ImportPlugin(options.module).apply(compiler);\n    new SystemPlugin(options.module).apply(compiler);\n    if (typeof options.mode !== \"string\") {\n      const WarnNoModeSetPlugin = require(\"./WarnNoModeSetPlugin\");\n      new WarnNoModeSetPlugin().apply(compiler);\n    }\n    const EnsureChunkConditionsPlugin = require(\"./optimize/EnsureChunkConditionsPlugin\");\n    new EnsureChunkConditionsPlugin().apply(compiler);\n    if (options.optimization.removeAvailableModules) {\n      const RemoveParentModulesPlugin = require(\"./optimize/RemoveParentModulesPlugin\");\n      new RemoveParentModulesPlugin().apply(compiler);\n    }\n    if (options.optimization.removeEmptyChunks) {\n      const RemoveEmptyChunksPlugin = require(\"./optimize/RemoveEmptyChunksPlugin\");\n      new RemoveEmptyChunksPlugin().apply(compiler);\n    }\n    if (options.optimization.mergeDuplicateChunks) {\n      const MergeDuplicateChunksPlugin = require(\"./optimize/MergeDuplicateChunksPlugin\");\n      new MergeDuplicateChunksPlugin().apply(compiler);\n    }\n    if (options.optimization.flagIncludedChunks) {\n      const FlagIncludedChunksPlugin = require(\"./optimize/FlagIncludedChunksPlugin\");\n      new FlagIncludedChunksPlugin().apply(compiler);\n    }\n    if (options.optimization.sideEffects) {\n      const SideEffectsFlagPlugin = require(\"./optimize/SideEffectsFlagPlugin\");\n      new SideEffectsFlagPlugin().apply(compiler);\n    }\n    if (options.optimization.providedExports) {\n      const FlagDependencyExportsPlugin = require(\"./FlagDependencyExportsPlugin\");\n      new FlagDependencyExportsPlugin().apply(compiler);\n    }\n    if (options.optimization.usedExports) {\n      const FlagDependencyUsagePlugin = require(\"./FlagDependencyUsagePlugin\");\n      new FlagDependencyUsagePlugin().apply(compiler);\n    }\n    if (options.optimization.concatenateModules) {\n      const ModuleConcatenationPlugin = require(\"./optimize/ModuleConcatenationPlugin\");\n      new ModuleConcatenationPlugin().apply(compiler);\n    }\n    if (options.optimization.splitChunks) {\n      const SplitChunksPlugin = require(\"./optimize/SplitChunksPlugin\");\n      new SplitChunksPlugin(options.optimization.splitChunks).apply(compiler);\n    }\n    if (options.optimization.runtimeChunk) {\n      const RuntimeChunkPlugin = require(\"./optimize/RuntimeChunkPlugin\");\n      new RuntimeChunkPlugin(options.optimization.runtimeChunk).apply(compiler);\n    }\n    if (options.optimization.noEmitOnErrors) {\n      const NoEmitOnErrorsPlugin = require(\"./NoEmitOnErrorsPlugin\");\n      new NoEmitOnErrorsPlugin().apply(compiler);\n    }\n    if (options.optimization.checkWasmTypes) {\n      const WasmFinalizeExportsPlugin = require(\"./wasm/WasmFinalizeExportsPlugin\");\n      new WasmFinalizeExportsPlugin().apply(compiler);\n    }\n    let moduleIds = options.optimization.moduleIds;\n    if (moduleIds === undefined) {\n      // TODO webpack 5 remove all these options\n      if (options.optimization.occurrenceOrder) {\n        moduleIds = \"size\";\n      }\n      if (options.optimization.namedModules) {\n        moduleIds = \"named\";\n      }\n      if (options.optimization.hashedModuleIds) {\n        moduleIds = \"hashed\";\n      }\n      if (moduleIds === undefined) {\n        moduleIds = \"natural\";\n      }\n    }\n    if (moduleIds) {\n      const NamedModulesPlugin = require(\"./NamedModulesPlugin\");\n      const HashedModuleIdsPlugin = require(\"./HashedModuleIdsPlugin\");\n      const OccurrenceModuleOrderPlugin = require(\"./optimize/OccurrenceModuleOrderPlugin\");\n      switch (moduleIds) {\n        case \"natural\":\n          // TODO webpack 5: see hint in Compilation.sortModules\n          break;\n        case \"named\":\n          new NamedModulesPlugin().apply(compiler);\n          break;\n        case \"hashed\":\n          new HashedModuleIdsPlugin().apply(compiler);\n          break;\n        case \"size\":\n          new OccurrenceModuleOrderPlugin({\n            prioritiseInitial: true\n          }).apply(compiler);\n          break;\n        case \"total-size\":\n          new OccurrenceModuleOrderPlugin({\n            prioritiseInitial: false\n          }).apply(compiler);\n          break;\n        default:\n          throw new Error(`webpack bug: moduleIds: ${moduleIds} is not implemented`);\n      }\n    }\n    let chunkIds = options.optimization.chunkIds;\n    if (chunkIds === undefined) {\n      // TODO webpack 5 remove all these options\n      if (options.optimization.occurrenceOrder) {\n        // This looks weird but it's for backward-compat\n        // This bug already existed before adding this feature\n        chunkIds = \"total-size\";\n      }\n      if (options.optimization.namedChunks) {\n        chunkIds = \"named\";\n      }\n      if (chunkIds === undefined) {\n        chunkIds = \"natural\";\n      }\n    }\n    if (chunkIds) {\n      const NaturalChunkOrderPlugin = require(\"./optimize/NaturalChunkOrderPlugin\");\n      const NamedChunksPlugin = require(\"./NamedChunksPlugin\");\n      const OccurrenceChunkOrderPlugin = require(\"./optimize/OccurrenceChunkOrderPlugin\");\n      switch (chunkIds) {\n        case \"natural\":\n          new NaturalChunkOrderPlugin().apply(compiler);\n          break;\n        case \"named\":\n          // TODO webapck 5: for backward-compat this need to have OccurrenceChunkOrderPlugin too\n          // The NamedChunksPlugin doesn't give every chunk a name\n          // This should be fixed, and the OccurrenceChunkOrderPlugin should be removed here.\n          new OccurrenceChunkOrderPlugin({\n            prioritiseInitial: false\n          }).apply(compiler);\n          new NamedChunksPlugin().apply(compiler);\n          break;\n        case \"size\":\n          new OccurrenceChunkOrderPlugin({\n            prioritiseInitial: true\n          }).apply(compiler);\n          break;\n        case \"total-size\":\n          new OccurrenceChunkOrderPlugin({\n            prioritiseInitial: false\n          }).apply(compiler);\n          break;\n        default:\n          throw new Error(`webpack bug: chunkIds: ${chunkIds} is not implemented`);\n      }\n    }\n    if (options.optimization.nodeEnv) {\n      const DefinePlugin = require(\"./DefinePlugin\");\n      new DefinePlugin({\n        \"process.env.NODE_ENV\": JSON.stringify(options.optimization.nodeEnv)\n      }).apply(compiler);\n    }\n    if (options.optimization.minimize) {\n      for (const minimizer of options.optimization.minimizer) {\n        if (typeof minimizer === \"function\") {\n          minimizer.call(compiler, compiler);\n        } else {\n          minimizer.apply(compiler);\n        }\n      }\n    }\n    if (options.performance) {\n      const SizeLimitsPlugin = require(\"./performance/SizeLimitsPlugin\");\n      new SizeLimitsPlugin(options.performance).apply(compiler);\n    }\n    new TemplatedPathPlugin().apply(compiler);\n    new RecordIdsPlugin({\n      portableIds: options.optimization.portableRecords\n    }).apply(compiler);\n    new WarnCaseSensitiveModulesPlugin().apply(compiler);\n    if (options.cache) {\n      const CachePlugin = require(\"./CachePlugin\");\n      new CachePlugin(typeof options.cache === \"object\" ? options.cache : null).apply(compiler);\n    }\n    compiler.hooks.afterPlugins.call(compiler);\n    if (!compiler.inputFileSystem) {\n      throw new Error(\"No input filesystem provided\");\n    }\n    compiler.resolverFactory.hooks.resolveOptions.for(\"normal\").tap(\"WebpackOptionsApply\", resolveOptions => {\n      return Object.assign({\n        fileSystem: compiler.inputFileSystem\n      }, cachedCleverMerge(options.resolve, resolveOptions));\n    });\n    compiler.resolverFactory.hooks.resolveOptions.for(\"context\").tap(\"WebpackOptionsApply\", resolveOptions => {\n      return Object.assign({\n        fileSystem: compiler.inputFileSystem,\n        resolveToContext: true\n      }, cachedCleverMerge(options.resolve, resolveOptions));\n    });\n    compiler.resolverFactory.hooks.resolveOptions.for(\"loader\").tap(\"WebpackOptionsApply\", resolveOptions => {\n      return Object.assign({\n        fileSystem: compiler.inputFileSystem\n      }, cachedCleverMerge(options.resolveLoader, resolveOptions));\n    });\n    compiler.hooks.afterResolvers.call(compiler);\n    return options;\n  }\n}\nmodule.exports = WebpackOptionsApply;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}