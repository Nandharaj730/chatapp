{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sean Larkin @thelarkinn\n*/\n\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nconst EntrypointsOverSizeLimitWarning = require(\"./EntrypointsOverSizeLimitWarning\");\nconst AssetsOverSizeLimitWarning = require(\"./AssetsOverSizeLimitWarning\");\nconst NoAsyncChunksWarning = require(\"./NoAsyncChunksWarning\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Entrypoint\")} Entrypoint */\n\nmodule.exports = class SizeLimitsPlugin {\n  constructor(options) {\n    this.hints = options.hints;\n    this.maxAssetSize = options.maxAssetSize;\n    this.maxEntrypointSize = options.maxEntrypointSize;\n    this.assetFilter = options.assetFilter;\n  }\n\n  /**\n   * @param {Compiler} compiler webpack compiler\n   * @returns {void}\n   */\n  apply(compiler) {\n    const entrypointSizeLimit = this.maxEntrypointSize;\n    const assetSizeLimit = this.maxAssetSize;\n    const hints = this.hints;\n    const assetFilter = this.assetFilter || ((name, source, info) => !info.development);\n    compiler.hooks.afterEmit.tap(\"SizeLimitsPlugin\", compilation => {\n      const warnings = [];\n\n      /**\n       * @param {Entrypoint} entrypoint an entrypoint\n       * @returns {number} the size of the entrypoint\n       */\n      const getEntrypointSize = entrypoint => entrypoint.getFiles().reduce((currentSize, file) => {\n        const asset = compilation.getAsset(file);\n        if (asset && assetFilter(asset.name, asset.source, asset.info) && asset.source) {\n          return currentSize + (asset.info.size || asset.source.size());\n        }\n        return currentSize;\n      }, 0);\n      const assetsOverSizeLimit = [];\n      for (const _ref of compilation.getAssets()) {\n        const name = _ref.name;\n        const source = _ref.source;\n        const info = _ref.info;\n        if (!assetFilter(name, source, info) || !source) {\n          continue;\n        }\n        const size = info.size || source.size();\n        if (size > assetSizeLimit) {\n          assetsOverSizeLimit.push({\n            name,\n            size\n          });\n          /** @type {any} */\n          source.isOverSizeLimit = true;\n        }\n      }\n      const fileFilter = name => {\n        const asset = compilation.getAsset(name);\n        return asset && assetFilter(asset.name, asset.source, asset.info);\n      };\n      const entrypointsOverLimit = [];\n      for (const _ref2 of compilation.entrypoints) {\n        var _ref3 = _slicedToArray(_ref2, 2);\n        const name = _ref3[0];\n        const entry = _ref3[1];\n        const size = getEntrypointSize(entry);\n        if (size > entrypointSizeLimit) {\n          entrypointsOverLimit.push({\n            name: name,\n            size: size,\n            files: entry.getFiles().filter(fileFilter)\n          });\n          /** @type {any} */\n          entry.isOverSizeLimit = true;\n        }\n      }\n      if (hints) {\n        // 1. Individual Chunk: Size < 250kb\n        // 2. Collective Initial Chunks [entrypoint] (Each Set?): Size < 250kb\n        // 3. No Async Chunks\n        // if !1, then 2, if !2 return\n        if (assetsOverSizeLimit.length > 0) {\n          warnings.push(new AssetsOverSizeLimitWarning(assetsOverSizeLimit, assetSizeLimit));\n        }\n        if (entrypointsOverLimit.length > 0) {\n          warnings.push(new EntrypointsOverSizeLimitWarning(entrypointsOverLimit, entrypointSizeLimit));\n        }\n        if (warnings.length > 0) {\n          const hasAsyncChunks = compilation.chunks.filter(chunk => !chunk.canBeInitial()).length > 0;\n          if (!hasAsyncChunks) {\n            warnings.push(new NoAsyncChunksWarning());\n          }\n          if (hints === \"error\") {\n            compilation.errors.push(...warnings);\n          } else {\n            compilation.warnings.push(...warnings);\n          }\n        }\n      }\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}