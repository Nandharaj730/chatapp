{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst GraphHelpers = require(\"./GraphHelpers\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {QueueItem[]} skippedItems queue items that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<Module>} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroup>} children set of children chunk groups, that will be revisited when availableModules shrink\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\nconst bySetSize = (a, b) => {\n  return b.size - a.size;\n};\n\n/**\n * Extracts simplified info from the modules and their dependencies\n * @param {Compilation} compilation the compilation\n * @returns {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} the mapping block to modules and inner blocks\n */\nconst extraceBlockInfoMap = compilation => {\n  /** @type {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} */\n  const blockInfoMap = new Map();\n\n  /**\n   * @param {Dependency} d dependency to iterate over\n   * @returns {void}\n   */\n  const iteratorDependency = d => {\n    // We skip Dependencies without Reference\n    const ref = compilation.getDependencyReference(currentModule, d);\n    if (!ref) {\n      return;\n    }\n    // We skip Dependencies without Module pointer\n    const refModule = ref.module;\n    if (!refModule) {\n      return;\n    }\n    // We skip weak Dependencies\n    if (ref.weak) {\n      return;\n    }\n    blockInfoModules.add(refModule);\n  };\n\n  /**\n   * @param {AsyncDependenciesBlock} b blocks to prepare\n   * @returns {void}\n   */\n  const iteratorBlockPrepare = b => {\n    blockInfoBlocks.push(b);\n    blockQueue.push(b);\n  };\n\n  /** @type {Module} */\n  let currentModule;\n  /** @type {DependenciesBlock} */\n  let block;\n  /** @type {DependenciesBlock[]} */\n  let blockQueue;\n  /** @type {Set<Module>} */\n  let blockInfoModules;\n  /** @type {AsyncDependenciesBlock[]} */\n  let blockInfoBlocks;\n  for (const module of compilation.modules) {\n    blockQueue = [module];\n    currentModule = module;\n    while (blockQueue.length > 0) {\n      block = blockQueue.pop();\n      blockInfoModules = new Set();\n      blockInfoBlocks = [];\n      if (block.variables) {\n        for (const variable of block.variables) {\n          for (const dep of variable.dependencies) iteratorDependency(dep);\n        }\n      }\n      if (block.dependencies) {\n        for (const dep of block.dependencies) iteratorDependency(dep);\n      }\n      if (block.blocks) {\n        for (const b of block.blocks) iteratorBlockPrepare(b);\n      }\n      const blockInfo = {\n        modules: blockInfoModules,\n        blocks: blockInfoBlocks\n      };\n      blockInfoMap.set(block, blockInfo);\n    }\n  }\n  return blockInfoMap;\n};\n\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups input groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\nconst visitModules = (compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups) => {\n  const logger = compilation.getLogger(\"webpack.buildChunkGraph.visitModules\");\n  const namedChunkGroups = compilation.namedChunkGroups;\n  logger.time(\"prepare\");\n  const blockInfoMap = extraceBlockInfoMap(compilation);\n\n  /** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n  const chunkGroupCounters = new Map();\n  for (const chunkGroup of inputChunkGroups) {\n    chunkGroupCounters.set(chunkGroup, {\n      index: 0,\n      index2: 0\n    });\n  }\n  let nextFreeModuleIndex = 0;\n  let nextFreeModuleIndex2 = 0;\n\n  /** @type {Map<DependenciesBlock, ChunkGroup>} */\n  const blockChunkGroups = new Map();\n  const ADD_AND_ENTER_MODULE = 0;\n  const ENTER_MODULE = 1;\n  const PROCESS_BLOCK = 2;\n  const LEAVE_MODULE = 3;\n\n  /**\n   * @param {QueueItem[]} queue the queue array (will be mutated)\n   * @param {ChunkGroup} chunkGroup chunk group\n   * @returns {QueueItem[]} the queue array again\n   */\n  const reduceChunkGroupToQueueItem = (queue, chunkGroup) => {\n    for (const chunk of chunkGroup.chunks) {\n      const module = chunk.entryModule;\n      queue.push({\n        action: ENTER_MODULE,\n        block: module,\n        module,\n        chunk,\n        chunkGroup\n      });\n    }\n    chunkGroupInfoMap.set(chunkGroup, {\n      chunkGroup,\n      minAvailableModules: new Set(),\n      minAvailableModulesOwned: true,\n      availableModulesToBeMerged: [],\n      skippedItems: [],\n      resultingAvailableModules: undefined,\n      children: undefined\n    });\n    return queue;\n  };\n\n  // Start with the provided modules/chunks\n  /** @type {QueueItem[]} */\n  let queue = inputChunkGroups.reduce(reduceChunkGroupToQueueItem, []).reverse();\n  /** @type {Map<ChunkGroup, Set<ChunkGroup>>} */\n  const queueConnect = new Map();\n  /** @type {Set<ChunkGroupInfo>} */\n  const outdatedChunkGroupInfo = new Set();\n  /** @type {QueueItem[]} */\n  let queueDelayed = [];\n  logger.timeEnd(\"prepare\");\n\n  /** @type {Module} */\n  let module;\n  /** @type {Chunk} */\n  let chunk;\n  /** @type {ChunkGroup} */\n  let chunkGroup;\n  /** @type {ChunkGroupInfo} */\n  let chunkGroupInfo;\n  /** @type {DependenciesBlock} */\n  let block;\n  /** @type {Set<Module>} */\n  let minAvailableModules;\n  /** @type {QueueItem[]} */\n  let skippedItems;\n\n  // For each async Block in graph\n  /**\n   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n   * @returns {void}\n   */\n  const iteratorBlock = b => {\n    // 1. We create a chunk for this Block\n    // but only once (blockChunkGroups map)\n    let c = blockChunkGroups.get(b);\n    if (c === undefined) {\n      c = namedChunkGroups.get(b.chunkName);\n      if (c && c.isInitial()) {\n        compilation.errors.push(new AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc));\n        c = chunkGroup;\n      } else {\n        c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);\n        chunkGroupCounters.set(c, {\n          index: 0,\n          index2: 0\n        });\n        blockChunkGroups.set(b, c);\n        allCreatedChunkGroups.add(c);\n      }\n      blockConnections.set(b, []);\n    } else {\n      // TODO webpack 5 remove addOptions check\n      if (c.addOptions) c.addOptions(b.groupOptions);\n      c.addOrigin(module, b.loc, b.request);\n    }\n\n    // 2. We store the connection for the block\n    // to connect it later if needed\n    blockConnections.get(b).push({\n      originChunkGroupInfo: chunkGroupInfo,\n      chunkGroup: c\n    });\n\n    // 3. We create/update the chunk group info\n    let connectList = queueConnect.get(chunkGroup);\n    if (connectList === undefined) {\n      connectList = new Set();\n      queueConnect.set(chunkGroup, connectList);\n    }\n    connectList.add(c);\n\n    // 4. We enqueue the DependenciesBlock for traversal\n    queueDelayed.push({\n      action: PROCESS_BLOCK,\n      block: b,\n      module: module,\n      chunk: c.chunks[0],\n      chunkGroup: c\n    });\n  };\n\n  // Iterative traversal of the Module graph\n  // Recursive would be simpler to write but could result in Stack Overflows\n  while (queue.length) {\n    logger.time(\"visiting\");\n    while (queue.length) {\n      const queueItem = queue.pop();\n      module = queueItem.module;\n      block = queueItem.block;\n      chunk = queueItem.chunk;\n      if (chunkGroup !== queueItem.chunkGroup) {\n        chunkGroup = queueItem.chunkGroup;\n        chunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);\n        minAvailableModules = chunkGroupInfo.minAvailableModules;\n        skippedItems = chunkGroupInfo.skippedItems;\n      }\n      switch (queueItem.action) {\n        case ADD_AND_ENTER_MODULE:\n          {\n            if (minAvailableModules.has(module)) {\n              // already in parent chunks\n              // skip it for now, but enqueue for rechecking when minAvailableModules shrinks\n              skippedItems.push(queueItem);\n              break;\n            }\n            // We connect Module and Chunk when not already done\n            if (chunk.addModule(module)) {\n              module.addChunk(chunk);\n            } else {\n              // already connected, skip it\n              break;\n            }\n          }\n        // fallthrough\n        case ENTER_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              const index = chunkGroup.getModuleIndex(module);\n              if (index === undefined) {\n                chunkGroup.setModuleIndex(module, chunkGroupCounters.get(chunkGroup).index++);\n              }\n            }\n            if (module.index === null) {\n              module.index = nextFreeModuleIndex++;\n            }\n            queue.push({\n              action: LEAVE_MODULE,\n              block,\n              module,\n              chunk,\n              chunkGroup\n            });\n          }\n        // fallthrough\n        case PROCESS_BLOCK:\n          {\n            // get prepared block info\n            const blockInfo = blockInfoMap.get(block);\n\n            // Buffer items because order need to be reverse to get indicies correct\n            const skipBuffer = [];\n            const queueBuffer = [];\n            // Traverse all referenced modules\n            for (const refModule of blockInfo.modules) {\n              if (chunk.containsModule(refModule)) {\n                // skip early if already connected\n                continue;\n              }\n              if (minAvailableModules.has(refModule)) {\n                // already in parent chunks, skip it for now\n                skipBuffer.push({\n                  action: ADD_AND_ENTER_MODULE,\n                  block: refModule,\n                  module: refModule,\n                  chunk,\n                  chunkGroup\n                });\n                continue;\n              }\n              // enqueue the add and enter to enter in the correct order\n              // this is relevant with circular dependencies\n              queueBuffer.push({\n                action: ADD_AND_ENTER_MODULE,\n                block: refModule,\n                module: refModule,\n                chunk,\n                chunkGroup\n              });\n            }\n            // Add buffered items in reversed order\n            for (let i = skipBuffer.length - 1; i >= 0; i--) {\n              skippedItems.push(skipBuffer[i]);\n            }\n            for (let i = queueBuffer.length - 1; i >= 0; i--) {\n              queue.push(queueBuffer[i]);\n            }\n\n            // Traverse all Blocks\n            for (const block of blockInfo.blocks) iteratorBlock(block);\n            if (blockInfo.blocks.length > 0 && module !== block) {\n              blocksWithNestedBlocks.add(block);\n            }\n            break;\n          }\n        case LEAVE_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              const index = chunkGroup.getModuleIndex2(module);\n              if (index === undefined) {\n                chunkGroup.setModuleIndex2(module, chunkGroupCounters.get(chunkGroup).index2++);\n              }\n            }\n            if (module.index2 === null) {\n              module.index2 = nextFreeModuleIndex2++;\n            }\n            break;\n          }\n      }\n    }\n    logger.timeEnd(\"visiting\");\n    while (queueConnect.size > 0) {\n      logger.time(\"calculating available modules\");\n\n      // Figure out new parents for chunk groups\n      // to get new available modules for these children\n      for (const _ref of queueConnect) {\n        var _ref2 = _slicedToArray(_ref, 2);\n        const chunkGroup = _ref2[0];\n        const targets = _ref2[1];\n        {\n          const info = chunkGroupInfoMap.get(chunkGroup);\n          let minAvailableModules = info.minAvailableModules;\n\n          // 1. Create a new Set of available modules at this points\n          const resultingAvailableModules = new Set(minAvailableModules);\n          for (const chunk of chunkGroup.chunks) {\n            for (const m of chunk.modulesIterable) {\n              resultingAvailableModules.add(m);\n            }\n          }\n          info.resultingAvailableModules = resultingAvailableModules;\n          if (info.children === undefined) {\n            info.children = targets;\n          } else {\n            for (const target of targets) {\n              info.children.add(target);\n            }\n          }\n\n          // 2. Update chunk group info\n          for (const target of targets) {\n            let chunkGroupInfo = chunkGroupInfoMap.get(target);\n            if (chunkGroupInfo === undefined) {\n              chunkGroupInfo = {\n                chunkGroup: target,\n                minAvailableModules: undefined,\n                minAvailableModulesOwned: undefined,\n                availableModulesToBeMerged: [],\n                skippedItems: [],\n                resultingAvailableModules: undefined,\n                children: undefined\n              };\n              chunkGroupInfoMap.set(target, chunkGroupInfo);\n            }\n            chunkGroupInfo.availableModulesToBeMerged.push(resultingAvailableModules);\n            outdatedChunkGroupInfo.add(chunkGroupInfo);\n          }\n        }\n      }\n      queueConnect.clear();\n      logger.timeEnd(\"calculating available modules\");\n      if (outdatedChunkGroupInfo.size > 0) {\n        logger.time(\"merging available modules\");\n        // Execute the merge\n        for (const info of outdatedChunkGroupInfo) {\n          const availableModulesToBeMerged = info.availableModulesToBeMerged;\n          let cachedMinAvailableModules = info.minAvailableModules;\n\n          // 1. Get minimal available modules\n          // It doesn't make sense to traverse a chunk again with more available modules.\n          // This step calculates the minimal available modules and skips traversal when\n          // the list didn't shrink.\n          if (availableModulesToBeMerged.length > 1) {\n            availableModulesToBeMerged.sort(bySetSize);\n          }\n          let changed = false;\n          for (const availableModules of availableModulesToBeMerged) {\n            if (cachedMinAvailableModules === undefined) {\n              cachedMinAvailableModules = availableModules;\n              info.minAvailableModules = cachedMinAvailableModules;\n              info.minAvailableModulesOwned = false;\n              changed = true;\n            } else {\n              if (info.minAvailableModulesOwned) {\n                // We own it and can modify it\n                for (const m of cachedMinAvailableModules) {\n                  if (!availableModules.has(m)) {\n                    cachedMinAvailableModules.delete(m);\n                    changed = true;\n                  }\n                }\n              } else {\n                for (const m of cachedMinAvailableModules) {\n                  if (!availableModules.has(m)) {\n                    // cachedMinAvailableModules need to be modified\n                    // but we don't own it\n                    // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n                    /** @type {Set<Module>} */\n                    const newSet = new Set();\n                    const iterator = cachedMinAvailableModules[Symbol.iterator]();\n                    /** @type {IteratorResult<Module>} */\n                    let it;\n                    while (!(it = iterator.next()).done) {\n                      const module = it.value;\n                      if (module === m) break;\n                      newSet.add(module);\n                    }\n                    while (!(it = iterator.next()).done) {\n                      const module = it.value;\n                      if (availableModules.has(module)) {\n                        newSet.add(module);\n                      }\n                    }\n                    cachedMinAvailableModules = newSet;\n                    info.minAvailableModulesOwned = true;\n                    info.minAvailableModules = newSet;\n\n                    // Update the cache from the first queue\n                    // if the chunkGroup is currently cached\n                    if (chunkGroup === info.chunkGroup) {\n                      minAvailableModules = cachedMinAvailableModules;\n                    }\n                    changed = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          availableModulesToBeMerged.length = 0;\n          if (!changed) continue;\n\n          // 2. Reconsider skipped items\n          for (const queueItem of info.skippedItems) {\n            queue.push(queueItem);\n          }\n          info.skippedItems.length = 0;\n\n          // 3. Reconsider children chunk groups\n          if (info.children !== undefined) {\n            const chunkGroup = info.chunkGroup;\n            for (const c of info.children) {\n              let connectList = queueConnect.get(chunkGroup);\n              if (connectList === undefined) {\n                connectList = new Set();\n                queueConnect.set(chunkGroup, connectList);\n              }\n              connectList.add(c);\n            }\n          }\n        }\n        outdatedChunkGroupInfo.clear();\n        logger.timeEnd(\"merging available modules\");\n      }\n    }\n\n    // Run queueDelayed when all items of the queue are processed\n    // This is important to get the global indicing correct\n    // Async blocks should be processed after all sync blocks are processed\n    if (queue.length === 0) {\n      const tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n  }\n};\n\n/**\n *\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\nconst connectChunkGroups = (blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap) => {\n  /**\n   * Helper function to check if all modules of a chunk are available\n   *\n   * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n   * @param {Set<Module>} availableModules the comparitor set\n   * @returns {boolean} return true if all modules of a chunk are available\n   */\n  const areModulesAvailable = (chunkGroup, availableModules) => {\n    for (const chunk of chunkGroup.chunks) {\n      for (const module of chunk.modulesIterable) {\n        if (!availableModules.has(module)) return false;\n      }\n    }\n    return true;\n  };\n\n  // For each edge in the basic chunk graph\n  for (const _ref3 of blockConnections) {\n    var _ref4 = _slicedToArray(_ref3, 2);\n    const block = _ref4[0];\n    const connections = _ref4[1];\n    // 1. Check if connection is needed\n    // When none of the dependencies need to be connected\n    // we can skip all of them\n    // It's not possible to filter each item so it doesn't create inconsistent\n    // connections and modules can only create one version\n    // TODO maybe decide this per runtime\n    if (\n    // TODO is this needed?\n    !blocksWithNestedBlocks.has(block) && connections.every(_ref5 => {\n      let chunkGroup = _ref5.chunkGroup,\n        originChunkGroupInfo = _ref5.originChunkGroupInfo;\n      return areModulesAvailable(chunkGroup, originChunkGroupInfo.resultingAvailableModules);\n    })) {\n      continue;\n    }\n\n    // 2. Foreach edge\n    for (let i = 0; i < connections.length; i++) {\n      const _connections$i = connections[i],\n        chunkGroup = _connections$i.chunkGroup,\n        originChunkGroupInfo = _connections$i.originChunkGroupInfo;\n\n      // 3. Connect block with chunk\n      GraphHelpers.connectDependenciesBlockAndChunkGroup(block, chunkGroup);\n\n      // 4. Connect chunk with parent\n      GraphHelpers.connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);\n    }\n  }\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n  for (const chunkGroup of allCreatedChunkGroups) {\n    if (chunkGroup.getNumberOfParents() === 0) {\n      for (const chunk of chunkGroup.chunks) {\n        const idx = compilation.chunks.indexOf(chunk);\n        if (idx >= 0) compilation.chunks.splice(idx, 1);\n        chunk.remove(\"unconnected\");\n      }\n      chunkGroup.remove(\"unconnected\");\n    }\n  }\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups chunk groups which are processed\n * @returns {void}\n */\nconst buildChunkGraph = (compilation, inputChunkGroups) => {\n  // SHARED STATE\n\n  /** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n  const blockConnections = new Map();\n\n  /** @type {Set<ChunkGroup>} */\n  const allCreatedChunkGroups = new Set();\n\n  /** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n  const chunkGroupInfoMap = new Map();\n\n  /** @type {Set<DependenciesBlock>} */\n  const blocksWithNestedBlocks = new Set();\n\n  // PART ONE\n\n  visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups);\n\n  // PART TWO\n\n  connectChunkGroups(blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap);\n\n  // Cleaup work\n\n  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n};\nmodule.exports = buildChunkGraph;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}