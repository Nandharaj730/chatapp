{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\n\"use strict\";\n\nconst LogType = Object.freeze({\n  error: /** @type {\"error\"} */\"error\",\n  // message, c style arguments\n  warn: /** @type {\"warn\"} */\"warn\",\n  // message, c style arguments\n  info: /** @type {\"info\"} */\"info\",\n  // message, c style arguments\n  log: /** @type {\"log\"} */\"log\",\n  // message, c style arguments\n  debug: /** @type {\"debug\"} */\"debug\",\n  // message, c style arguments\n\n  trace: /** @type {\"trace\"} */\"trace\",\n  // no arguments\n\n  group: /** @type {\"group\"} */\"group\",\n  // [label]\n  groupCollapsed: /** @type {\"groupCollapsed\"} */\"groupCollapsed\",\n  // [label]\n  groupEnd: /** @type {\"groupEnd\"} */\"groupEnd\",\n  // [label]\n\n  profile: /** @type {\"profile\"} */\"profile\",\n  // [profileName]\n  profileEnd: /** @type {\"profileEnd\"} */\"profileEnd\",\n  // [profileName]\n\n  time: /** @type {\"time\"} */\"time\",\n  // name, time as [seconds, nanoseconds]\n\n  clear: /** @type {\"clear\"} */\"clear\",\n  // no arguments\n  status: /** @type {\"status\"} */\"status\" // message, arguments\n});\n\nexports.LogType = LogType;\n\n/** @typedef {typeof LogType[keyof typeof LogType]} LogTypeEnum */\n\nconst LOG_SYMBOL = Symbol(\"webpack logger raw log method\");\nconst TIMERS_SYMBOL = Symbol(\"webpack logger times\");\nclass WebpackLogger {\n  /**\n   * @param {function(LogTypeEnum, any[]=): void} log log function\n   */\n  constructor(log) {\n    this[LOG_SYMBOL] = log;\n  }\n  error() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    this[LOG_SYMBOL](LogType.error, args);\n  }\n  warn() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    this[LOG_SYMBOL](LogType.warn, args);\n  }\n  info() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    this[LOG_SYMBOL](LogType.info, args);\n  }\n  log() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    this[LOG_SYMBOL](LogType.log, args);\n  }\n  debug() {\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    this[LOG_SYMBOL](LogType.debug, args);\n  }\n  assert(assertion) {\n    if (!assertion) {\n      for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n        args[_key6 - 1] = arguments[_key6];\n      }\n      this[LOG_SYMBOL](LogType.error, args);\n    }\n  }\n  trace() {\n    this[LOG_SYMBOL](LogType.trace, [\"Trace\"]);\n  }\n  clear() {\n    this[LOG_SYMBOL](LogType.clear);\n  }\n  status() {\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    this[LOG_SYMBOL](LogType.status, args);\n  }\n  group() {\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    this[LOG_SYMBOL](LogType.group, args);\n  }\n  groupCollapsed() {\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n    this[LOG_SYMBOL](LogType.groupCollapsed, args);\n  }\n  groupEnd() {\n    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      args[_key10] = arguments[_key10];\n    }\n    this[LOG_SYMBOL](LogType.groupEnd, args);\n  }\n  profile(label) {\n    this[LOG_SYMBOL](LogType.profile, [label]);\n  }\n  profileEnd(label) {\n    this[LOG_SYMBOL](LogType.profileEnd, [label]);\n  }\n  time(label) {\n    this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || new Map();\n    this[TIMERS_SYMBOL].set(label, process.hrtime());\n  }\n  timeLog(label) {\n    const prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);\n    if (!prev) {\n      throw new Error(`No such label '${label}' for WebpackLogger.timeLog()`);\n    }\n    const time = process.hrtime(prev);\n    this[LOG_SYMBOL](LogType.time, [label, ...time]);\n  }\n  timeEnd(label) {\n    const prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);\n    if (!prev) {\n      throw new Error(`No such label '${label}' for WebpackLogger.timeEnd()`);\n    }\n    const time = process.hrtime(prev);\n    this[TIMERS_SYMBOL].delete(label);\n    this[LOG_SYMBOL](LogType.time, [label, ...time]);\n  }\n}\nexports.Logger = WebpackLogger;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}