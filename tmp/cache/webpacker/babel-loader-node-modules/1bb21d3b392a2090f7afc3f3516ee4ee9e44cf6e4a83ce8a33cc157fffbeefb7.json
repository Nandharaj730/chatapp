{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nconst Generator = require(\"../Generator\");\nconst Template = require(\"../Template\");\nconst _require = require(\"webpack-sources\"),\n  RawSource = _require.RawSource;\nconst WebAssemblyImportDependency = require(\"../dependencies/WebAssemblyImportDependency\");\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Dependency\").DependencyTemplate} DependencyTemplate */\n\nclass WebAssemblyJavascriptGenerator extends Generator {\n  /**\n   * @param {NormalModule} module module for which the code should be generated\n   * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates\n   * @param {RuntimeTemplate} runtimeTemplate the runtime template\n   * @param {string} type which kind of code should be generated\n   * @returns {Source} generated code\n   */\n  generate(module, dependencyTemplates, runtimeTemplate, type) {\n    const initIdentifer = Array.isArray(module.usedExports) ? Template.numberToIdentifer(module.usedExports.length) : \"__webpack_init__\";\n    let needExportsCopy = false;\n    const importedModules = new Map();\n    const initParams = [];\n    let index = 0;\n    for (const dep of module.dependencies) {\n      const depAsAny = /** @type {any} */dep;\n      if (dep.module) {\n        let importData = importedModules.get(dep.module);\n        if (importData === undefined) {\n          importedModules.set(dep.module, importData = {\n            importVar: `m${index}`,\n            index,\n            request: \"userRequest\" in depAsAny ? depAsAny.userRequest : undefined,\n            names: new Set(),\n            reexports: []\n          });\n          index++;\n        }\n        if (dep instanceof WebAssemblyImportDependency) {\n          importData.names.add(dep.name);\n          if (dep.description.type === \"GlobalType\") {\n            const exportName = dep.name;\n            const usedName = dep.module && dep.module.isUsed(exportName);\n            if (dep.module) {\n              if (usedName) {\n                initParams.push(runtimeTemplate.exportFromImport({\n                  module: dep.module,\n                  request: dep.request,\n                  importVar: importData.importVar,\n                  originModule: module,\n                  exportName: dep.name,\n                  asiSafe: true,\n                  isCall: false,\n                  callContext: null\n                }));\n              }\n            }\n          }\n        }\n        if (dep instanceof WebAssemblyExportImportedDependency) {\n          importData.names.add(dep.name);\n          const usedName = module.isUsed(dep.exportName);\n          if (usedName) {\n            const exportProp = `${module.exportsArgument}[${JSON.stringify(usedName)}]`;\n            const defineStatement = Template.asString([`${exportProp} = ${runtimeTemplate.exportFromImport({\n              module: dep.module,\n              request: dep.request,\n              importVar: importData.importVar,\n              originModule: module,\n              exportName: dep.name,\n              asiSafe: true,\n              isCall: false,\n              callContext: null\n            })};`, `if(WebAssembly.Global) ${exportProp} = ` + `new WebAssembly.Global({ value: ${JSON.stringify(dep.valueType)} }, ${exportProp});`]);\n            importData.reexports.push(defineStatement);\n            needExportsCopy = true;\n          }\n        }\n      }\n    }\n    const importsCode = Template.asString(Array.from(importedModules, _ref => {\n      let _ref2 = _slicedToArray(_ref, 2),\n        module = _ref2[0],\n        _ref2$ = _ref2[1],\n        importVar = _ref2$.importVar,\n        request = _ref2$.request,\n        reexports = _ref2$.reexports;\n      const importStatement = runtimeTemplate.importStatement({\n        module,\n        request,\n        importVar,\n        originModule: module\n      });\n      return importStatement + reexports.join(\"\\n\");\n    }));\n\n    // create source\n    const source = new RawSource(['\"use strict\";', \"// Instantiate WebAssembly module\", \"var wasmExports = __webpack_require__.w[module.i];\", !Array.isArray(module.usedExports) ? `__webpack_require__.r(${module.exportsArgument});` : \"\",\n    // this must be before import for circular dependencies\n    \"// export exports from WebAssembly module\", Array.isArray(module.usedExports) && !needExportsCopy ? `${module.moduleArgument}.exports = wasmExports;` : \"for(var name in wasmExports) \" + `if(name != ${JSON.stringify(initIdentifer)}) ` + `${module.exportsArgument}[name] = wasmExports[name];`, \"// exec imports from WebAssembly module (for esm order)\", importsCode, \"\", \"// exec wasm module\", `wasmExports[${JSON.stringify(initIdentifer)}](${initParams.join(\", \")})`].join(\"\\n\"));\n    return source;\n  }\n}\nmodule.exports = WebAssemblyJavascriptGenerator;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}