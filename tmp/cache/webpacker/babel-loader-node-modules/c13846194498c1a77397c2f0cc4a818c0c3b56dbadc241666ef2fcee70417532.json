{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Resolver = require(\"./Resolver\");\nconst SyncAsyncFileSystemDecorator = require(\"./SyncAsyncFileSystemDecorator\");\nconst ParsePlugin = require(\"./ParsePlugin\");\nconst DescriptionFilePlugin = require(\"./DescriptionFilePlugin\");\nconst NextPlugin = require(\"./NextPlugin\");\nconst TryNextPlugin = require(\"./TryNextPlugin\");\nconst ModuleKindPlugin = require(\"./ModuleKindPlugin\");\nconst FileKindPlugin = require(\"./FileKindPlugin\");\nconst JoinRequestPlugin = require(\"./JoinRequestPlugin\");\nconst ModulesInHierachicDirectoriesPlugin = require(\"./ModulesInHierachicDirectoriesPlugin\");\nconst ModulesInRootPlugin = require(\"./ModulesInRootPlugin\");\nconst AliasPlugin = require(\"./AliasPlugin\");\nconst AliasFieldPlugin = require(\"./AliasFieldPlugin\");\nconst ConcordExtensionsPlugin = require(\"./ConcordExtensionsPlugin\");\nconst ConcordMainPlugin = require(\"./ConcordMainPlugin\");\nconst ConcordModulesPlugin = require(\"./ConcordModulesPlugin\");\nconst DirectoryExistsPlugin = require(\"./DirectoryExistsPlugin\");\nconst FileExistsPlugin = require(\"./FileExistsPlugin\");\nconst SymlinkPlugin = require(\"./SymlinkPlugin\");\nconst MainFieldPlugin = require(\"./MainFieldPlugin\");\nconst UseFilePlugin = require(\"./UseFilePlugin\");\nconst AppendPlugin = require(\"./AppendPlugin\");\nconst RootPlugin = require(\"./RootPlugin\");\nconst RestrictionsPlugin = require(\"./RestrictionsPlugin\");\nconst ResultPlugin = require(\"./ResultPlugin\");\nconst ModuleAppendPlugin = require(\"./ModuleAppendPlugin\");\nconst UnsafeCachePlugin = require(\"./UnsafeCachePlugin\");\nexports.createResolver = function (options) {\n  //// OPTIONS ////\n\n  // A list of directories to resolve modules from, can be absolute path or folder name\n  let modules = options.modules || [\"node_modules\"];\n\n  // A list of description files to read from\n  const descriptionFiles = options.descriptionFiles || [\"package.json\"];\n\n  // A list of additional resolve plugins which should be applied\n  // The slice is there to create a copy, because otherwise pushing into plugins\n  // changes the original options.plugins array, causing duplicate plugins\n  const plugins = options.plugins && options.plugins.slice() || [];\n\n  // A list of main fields in description files\n  let mainFields = options.mainFields || [\"main\"];\n\n  // A list of alias fields in description files\n  const aliasFields = options.aliasFields || [];\n\n  // A list of main files in directories\n  const mainFiles = options.mainFiles || [\"index\"];\n\n  // A list of extensions which should be tried for files\n  let extensions = options.extensions || [\".js\", \".json\", \".node\"];\n\n  // Enforce that a extension from extensions must be used\n  const enforceExtension = options.enforceExtension || false;\n\n  // A list of module extensions which should be tried for modules\n  let moduleExtensions = options.moduleExtensions || [];\n\n  // Enforce that a extension from moduleExtensions must be used\n  const enforceModuleExtension = options.enforceModuleExtension || false;\n\n  // A list of module alias configurations or an object which maps key to value\n  let alias = options.alias || [];\n\n  // Resolve symlinks to their symlinked location\n  const symlinks = typeof options.symlinks !== \"undefined\" ? options.symlinks : true;\n\n  // Resolve to a context instead of a file\n  const resolveToContext = options.resolveToContext || false;\n\n  // A list of root paths\n  const roots = options.roots || [];\n\n  // Ignore errors happening when resolving roots\n  const ignoreRootsErrors = options.ignoreRootsErrors || false;\n\n  // Prefer to resolve server-relative urls as absolute paths before falling back to resolve in roots\n  const preferAbsolute = options.preferAbsolute || false;\n  const restrictions = options.restrictions || [];\n\n  // Use this cache object to unsafely cache the successful requests\n  let unsafeCache = options.unsafeCache || false;\n\n  // Whether or not the unsafeCache should include request context as part of the cache key.\n  const cacheWithContext = typeof options.cacheWithContext !== \"undefined\" ? options.cacheWithContext : true;\n\n  // Enable concord description file instructions\n  const enableConcord = options.concord || false;\n\n  // A function which decides whether a request should be cached or not.\n  // an object is passed with `path` and `request` properties.\n  const cachePredicate = options.cachePredicate || function () {\n    return true;\n  };\n\n  // The file system which should be used\n  const fileSystem = options.fileSystem;\n\n  // Use only the sync constiants of the file system calls\n  const useSyncFileSystemCalls = options.useSyncFileSystemCalls;\n\n  // A prepared Resolver to which the plugins are attached\n  let resolver = options.resolver;\n\n  //// options processing ////\n\n  if (!resolver) {\n    resolver = new Resolver(useSyncFileSystemCalls ? new SyncAsyncFileSystemDecorator(fileSystem) : fileSystem);\n  }\n  extensions = [].concat(extensions);\n  moduleExtensions = [].concat(moduleExtensions);\n  modules = mergeFilteredToArray([].concat(modules), item => {\n    return !isAbsolutePath(item);\n  });\n  mainFields = mainFields.map(item => {\n    if (typeof item === \"string\" || Array.isArray(item)) {\n      item = {\n        name: item,\n        forceRelative: true\n      };\n    }\n    return item;\n  });\n  if (typeof alias === \"object\" && !Array.isArray(alias)) {\n    alias = Object.keys(alias).map(key => {\n      let onlyModule = false;\n      let obj = alias[key];\n      if (/\\$$/.test(key)) {\n        onlyModule = true;\n        key = key.substr(0, key.length - 1);\n      }\n      if (typeof obj === \"string\") {\n        obj = {\n          alias: obj\n        };\n      }\n      obj = Object.assign({\n        name: key,\n        onlyModule: onlyModule\n      }, obj);\n      return obj;\n    });\n  }\n  if (unsafeCache && typeof unsafeCache !== \"object\") {\n    unsafeCache = {};\n  }\n\n  //// pipeline ////\n\n  resolver.ensureHook(\"resolve\");\n  resolver.ensureHook(\"parsedResolve\");\n  resolver.ensureHook(\"describedResolve\");\n  resolver.ensureHook(\"rawModule\");\n  resolver.ensureHook(\"module\");\n  resolver.ensureHook(\"relative\");\n  resolver.ensureHook(\"describedRelative\");\n  resolver.ensureHook(\"directory\");\n  resolver.ensureHook(\"existingDirectory\");\n  resolver.ensureHook(\"undescribedRawFile\");\n  resolver.ensureHook(\"rawFile\");\n  resolver.ensureHook(\"file\");\n  resolver.ensureHook(\"existingFile\");\n  resolver.ensureHook(\"resolved\");\n\n  // resolve\n  if (unsafeCache) {\n    plugins.push(new UnsafeCachePlugin(\"resolve\", cachePredicate, unsafeCache, cacheWithContext, \"new-resolve\"));\n    plugins.push(new ParsePlugin(\"new-resolve\", \"parsed-resolve\"));\n  } else {\n    plugins.push(new ParsePlugin(\"resolve\", \"parsed-resolve\"));\n  }\n\n  // parsed-resolve\n  plugins.push(new DescriptionFilePlugin(\"parsed-resolve\", descriptionFiles, \"described-resolve\"));\n  plugins.push(new NextPlugin(\"after-parsed-resolve\", \"described-resolve\"));\n\n  // described-resolve\n  if (alias.length > 0) plugins.push(new AliasPlugin(\"described-resolve\", alias, \"resolve\"));\n  if (enableConcord) {\n    plugins.push(new ConcordModulesPlugin(\"described-resolve\", {}, \"resolve\"));\n  }\n  aliasFields.forEach(item => {\n    plugins.push(new AliasFieldPlugin(\"described-resolve\", item, \"resolve\"));\n  });\n  plugins.push(new ModuleKindPlugin(\"after-described-resolve\", \"raw-module\"));\n  if (preferAbsolute) {\n    plugins.push(new JoinRequestPlugin(\"after-described-resolve\", \"relative\"));\n  }\n  roots.forEach(root => {\n    plugins.push(new RootPlugin(\"after-described-resolve\", root, \"relative\", ignoreRootsErrors));\n  });\n  if (!preferAbsolute) {\n    plugins.push(new JoinRequestPlugin(\"after-described-resolve\", \"relative\"));\n  }\n\n  // raw-module\n  moduleExtensions.forEach(item => {\n    plugins.push(new ModuleAppendPlugin(\"raw-module\", item, \"module\"));\n  });\n  if (!enforceModuleExtension) plugins.push(new TryNextPlugin(\"raw-module\", null, \"module\"));\n\n  // module\n  modules.forEach(item => {\n    if (Array.isArray(item)) plugins.push(new ModulesInHierachicDirectoriesPlugin(\"module\", item, \"resolve\"));else plugins.push(new ModulesInRootPlugin(\"module\", item, \"resolve\"));\n  });\n\n  // relative\n  plugins.push(new DescriptionFilePlugin(\"relative\", descriptionFiles, \"described-relative\"));\n  plugins.push(new NextPlugin(\"after-relative\", \"described-relative\"));\n\n  // described-relative\n  plugins.push(new FileKindPlugin(\"described-relative\", \"raw-file\"));\n  plugins.push(new TryNextPlugin(\"described-relative\", \"as directory\", \"directory\"));\n\n  // directory\n  plugins.push(new DirectoryExistsPlugin(\"directory\", \"existing-directory\"));\n  if (resolveToContext) {\n    // existing-directory\n    plugins.push(new NextPlugin(\"existing-directory\", \"resolved\"));\n  } else {\n    // existing-directory\n    if (enableConcord) {\n      plugins.push(new ConcordMainPlugin(\"existing-directory\", {}, \"resolve\"));\n    }\n    mainFields.forEach(item => {\n      plugins.push(new MainFieldPlugin(\"existing-directory\", item, \"resolve\"));\n    });\n    mainFiles.forEach(item => {\n      plugins.push(new UseFilePlugin(\"existing-directory\", item, \"undescribed-raw-file\"));\n    });\n\n    // undescribed-raw-file\n    plugins.push(new DescriptionFilePlugin(\"undescribed-raw-file\", descriptionFiles, \"raw-file\"));\n    plugins.push(new NextPlugin(\"after-undescribed-raw-file\", \"raw-file\"));\n\n    // raw-file\n    if (!enforceExtension) {\n      plugins.push(new TryNextPlugin(\"raw-file\", \"no extension\", \"file\"));\n    }\n    if (enableConcord) {\n      plugins.push(new ConcordExtensionsPlugin(\"raw-file\", {}, \"file\"));\n    }\n    extensions.forEach(item => {\n      plugins.push(new AppendPlugin(\"raw-file\", item, \"file\"));\n    });\n\n    // file\n    if (alias.length > 0) plugins.push(new AliasPlugin(\"file\", alias, \"resolve\"));\n    if (enableConcord) {\n      plugins.push(new ConcordModulesPlugin(\"file\", {}, \"resolve\"));\n    }\n    aliasFields.forEach(item => {\n      plugins.push(new AliasFieldPlugin(\"file\", item, \"resolve\"));\n    });\n    if (symlinks) plugins.push(new SymlinkPlugin(\"file\", \"relative\"));\n    plugins.push(new FileExistsPlugin(\"file\", \"existing-file\"));\n\n    // existing-file\n    plugins.push(new NextPlugin(\"existing-file\", \"resolved\"));\n  }\n\n  // resolved\n  if (restrictions.length > 0) {\n    plugins.push(new RestrictionsPlugin(resolver.hooks.resolved, restrictions));\n  }\n  plugins.push(new ResultPlugin(resolver.hooks.resolved));\n\n  //// RESOLVER ////\n\n  plugins.forEach(plugin => {\n    plugin.apply(resolver);\n  });\n  return resolver;\n};\nfunction mergeFilteredToArray(array, filter) {\n  return array.reduce((array, item) => {\n    if (filter(item)) {\n      const lastElement = array[array.length - 1];\n      if (Array.isArray(lastElement)) {\n        lastElement.push(item);\n      } else {\n        array.push([item]);\n      }\n      return array;\n    } else {\n      array.push(item);\n      return array;\n    }\n  }, []);\n}\nfunction isAbsolutePath(path) {\n  return /^[A-Z]:|^\\//.test(path);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}