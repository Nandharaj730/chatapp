{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Jason Anderson @diurnalist\n*/\n\"use strict\";\n\nconst REGEXP_HASH = /\\[hash(?::(\\d+))?\\]/gi,\n  REGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/gi,\n  REGEXP_MODULEHASH = /\\[modulehash(?::(\\d+))?\\]/gi,\n  REGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/gi,\n  REGEXP_NAME = /\\[name\\]/gi,\n  REGEXP_ID = /\\[id\\]/gi,\n  REGEXP_MODULEID = /\\[moduleid\\]/gi,\n  REGEXP_FILE = /\\[file\\]/gi,\n  REGEXP_QUERY = /\\[query\\]/gi,\n  REGEXP_FILEBASE = /\\[filebase\\]/gi,\n  REGEXP_URL = /\\[url\\]/gi;\n\n// Using global RegExp for .test is dangerous\n// We use a normal RegExp instead of .test\nconst REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, \"i\"),\n  REGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, \"i\"),\n  REGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, \"i\"),\n  REGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, \"i\");\nconst withHashLength = (replacer, handlerFn, assetInfo) => {\n  const fn = function (match, hashLength) {\n    if (assetInfo) assetInfo.immutable = true;\n    const length = hashLength && parseInt(hashLength, 10);\n    if (length && handlerFn) {\n      return handlerFn(length);\n    }\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    const hash = replacer(match, hashLength, ...args);\n    return length ? hash.slice(0, length) : hash;\n  };\n  return fn;\n};\nconst getReplacer = (value, allowEmpty) => {\n  const fn = function (match) {\n    var _ref;\n    // last argument in replacer is the entire input string\n    const input = (_ref = (arguments.length <= 1 ? 0 : arguments.length - 1) - 1 + 1, _ref < 1 || arguments.length <= _ref ? undefined : arguments[_ref]);\n    if (value === null || value === undefined) {\n      if (!allowEmpty) {\n        throw new Error(`Path variable ${match} not implemented in this context: ${input}`);\n      }\n      return \"\";\n    } else {\n      return `${escapePathVariables(value)}`;\n    }\n  };\n  return fn;\n};\nconst escapePathVariables = value => {\n  return typeof value === \"string\" ? value.replace(/\\[(\\\\*[\\w:]+\\\\*)\\]/gi, \"[\\\\$1\\\\]\") : value;\n};\nconst replacePathVariables = (path, data, assetInfo) => {\n  const chunk = data.chunk;\n  const chunkId = chunk && chunk.id;\n  const chunkName = chunk && (chunk.name || chunk.id);\n  const chunkHash = chunk && (chunk.renderedHash || chunk.hash);\n  const chunkHashWithLength = chunk && chunk.hashWithLength;\n  const contentHashType = data.contentHashType;\n  const contentHash = chunk && chunk.contentHash && chunk.contentHash[contentHashType] || data.contentHash;\n  const contentHashWithLength = chunk && chunk.contentHashWithLength && chunk.contentHashWithLength[contentHashType] || data.contentHashWithLength;\n  const module = data.module;\n  const moduleId = module && module.id;\n  const moduleHash = module && (module.renderedHash || module.hash);\n  const moduleHashWithLength = module && module.hashWithLength;\n  if (typeof path === \"function\") {\n    path = path(data);\n  }\n  if (data.noChunkHash && (REGEXP_CHUNKHASH_FOR_TEST.test(path) || REGEXP_CONTENTHASH_FOR_TEST.test(path))) {\n    throw new Error(`Cannot use [chunkhash] or [contenthash] for chunk in '${path}' (use [hash] instead)`);\n  }\n  return path.replace(REGEXP_HASH, withHashLength(getReplacer(data.hash), data.hashWithLength, assetInfo)).replace(REGEXP_CHUNKHASH, withHashLength(getReplacer(chunkHash), chunkHashWithLength, assetInfo)).replace(REGEXP_CONTENTHASH, withHashLength(getReplacer(contentHash), contentHashWithLength, assetInfo)).replace(REGEXP_MODULEHASH, withHashLength(getReplacer(moduleHash), moduleHashWithLength, assetInfo)).replace(REGEXP_ID, getReplacer(chunkId)).replace(REGEXP_MODULEID, getReplacer(moduleId)).replace(REGEXP_NAME, getReplacer(chunkName)).replace(REGEXP_FILE, getReplacer(data.filename)).replace(REGEXP_FILEBASE, getReplacer(data.basename))\n  // query is optional, it's OK if it's in a path but there's nothing to replace it with\n  .replace(REGEXP_QUERY, getReplacer(data.query, true))\n  // only available in sourceMappingURLComment\n  .replace(REGEXP_URL, getReplacer(data.url)).replace(/\\[\\\\(\\\\*[\\w:]+\\\\*)\\\\\\]/gi, \"[$1]\");\n};\nclass TemplatedPathPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"TemplatedPathPlugin\", compilation => {\n      const mainTemplate = compilation.mainTemplate;\n      mainTemplate.hooks.assetPath.tap(\"TemplatedPathPlugin\", replacePathVariables);\n      mainTemplate.hooks.globalHash.tap(\"TemplatedPathPlugin\", (chunk, paths) => {\n        const outputOptions = mainTemplate.outputOptions;\n        const publicPath = outputOptions.publicPath || \"\";\n        const filename = outputOptions.filename || \"\";\n        const chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n        if (REGEXP_HASH_FOR_TEST.test(publicPath) || REGEXP_CHUNKHASH_FOR_TEST.test(publicPath) || REGEXP_CONTENTHASH_FOR_TEST.test(publicPath) || REGEXP_NAME_FOR_TEST.test(publicPath)) return true;\n        if (REGEXP_HASH_FOR_TEST.test(filename)) return true;\n        if (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;\n        if (REGEXP_HASH_FOR_TEST.test(paths.join(\"|\"))) return true;\n      });\n      mainTemplate.hooks.hashForChunk.tap(\"TemplatedPathPlugin\", (hash, chunk) => {\n        const outputOptions = mainTemplate.outputOptions;\n        const chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n        if (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n        }\n        if (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash.javascript || {}));\n        }\n        if (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n        }\n      });\n    });\n  }\n}\nmodule.exports = TemplatedPathPlugin;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}