{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst SortableSet = require(\"./SortableSet\");\n\n/**\n * @template T\n * @template K\n * Multi layer bucket sorted set\n * Supports adding non-existing items (DO NOT ADD ITEM TWICE)\n * Supports removing exiting items (DO NOT REMOVE ITEM NOT IN SET)\n * Supports popping the first items according to defined order\n * Supports iterating all items without order\n * Supports updating an item in an efficient way\n * Supports size property, which is the number of items\n * Items are lazy partially sorted when needed\n */\nclass LazyBucketSortedSet {\n  /**\n   * @param {function(T): K} getKey function to get key from item\n   * @param {function(K, K): number} comparator comparator to sort keys\n   * @param  {...((function(T): any) | (function(any, any): number))} args more pairs of getKey and comparator plus optional final comparator for the last layer\n   */\n  constructor(getKey, comparator) {\n    this._getKey = getKey;\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    this._innerArgs = args;\n    this._leaf = args.length <= 1;\n    this._keys = new SortableSet(undefined, comparator);\n    /** @type {Map<K, LazyBucketSortedSet<T, any> | SortableSet<T>>} */\n    this._map = new Map();\n    this._unsortedItems = new Set();\n    this.size = 0;\n  }\n\n  /**\n   * @param {T} item an item\n   * @returns {void}\n   */\n  add(item) {\n    this.size++;\n    this._unsortedItems.add(item);\n  }\n\n  /**\n   * @param {K} key key of item\n   * @param {T} item the item\n   * @returns {void}\n   */\n  _addInternal(key, item) {\n    let entry = this._map.get(key);\n    if (entry === undefined) {\n      entry = this._leaf ? new SortableSet(undefined, this._innerArgs[0]) : new /** @type {any} */LazyBucketSortedSet(...this._innerArgs);\n      this._keys.add(key);\n      this._map.set(key, entry);\n    }\n    entry.add(item);\n  }\n\n  /**\n   * @param {T} item an item\n   * @returns {void}\n   */\n  delete(item) {\n    this.size--;\n    if (this._unsortedItems.has(item)) {\n      this._unsortedItems.delete(item);\n      return;\n    }\n    const key = this._getKey(item);\n    const entry = this._map.get(key);\n    entry.delete(item);\n    if (entry.size === 0) {\n      this._deleteKey(key);\n    }\n  }\n\n  /**\n   * @param {K} key key to be removed\n   * @returns {void}\n   */\n  _deleteKey(key) {\n    this._keys.delete(key);\n    this._map.delete(key);\n  }\n\n  /**\n   * @returns {T | undefined} an item\n   */\n  popFirst() {\n    if (this.size === 0) return undefined;\n    this.size--;\n    if (this._unsortedItems.size > 0) {\n      for (const item of this._unsortedItems) {\n        const key = this._getKey(item);\n        this._addInternal(key, item);\n      }\n      this._unsortedItems.clear();\n    }\n    this._keys.sort();\n    const key = this._keys.values().next().value;\n    const entry = this._map.get(key);\n    if (this._leaf) {\n      const leafEntry = /** @type {SortableSet<T>} */entry;\n      leafEntry.sort();\n      const item = leafEntry.values().next().value;\n      leafEntry.delete(item);\n      if (leafEntry.size === 0) {\n        this._deleteKey(key);\n      }\n      return item;\n    } else {\n      const nodeEntry = /** @type {LazyBucketSortedSet<T, any>} */entry;\n      const item = nodeEntry.popFirst();\n      if (nodeEntry.size === 0) {\n        this._deleteKey(key);\n      }\n      return item;\n    }\n  }\n\n  /**\n   * @param {T} item to be updated item\n   * @returns {function(true=): void} finish update\n   */\n  startUpdate(item) {\n    if (this._unsortedItems.has(item)) {\n      return remove => {\n        if (remove) {\n          this._unsortedItems.delete(item);\n          this.size--;\n          return;\n        }\n      };\n    }\n    const key = this._getKey(item);\n    if (this._leaf) {\n      const oldEntry = /** @type {SortableSet<T>} */this._map.get(key);\n      return remove => {\n        if (remove) {\n          this.size--;\n          oldEntry.delete(item);\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n          return;\n        }\n        const newKey = this._getKey(item);\n        if (key === newKey) {\n          // This flags the sortable set as unordered\n          oldEntry.add(item);\n        } else {\n          oldEntry.delete(item);\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n          this._addInternal(newKey, item);\n        }\n      };\n    } else {\n      const oldEntry = /** @type {LazyBucketSortedSet<T, any>} */this._map.get(key);\n      const finishUpdate = oldEntry.startUpdate(item);\n      return remove => {\n        if (remove) {\n          this.size--;\n          finishUpdate(true);\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n          return;\n        }\n        const newKey = this._getKey(item);\n        if (key === newKey) {\n          finishUpdate();\n        } else {\n          finishUpdate(true);\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n          this._addInternal(newKey, item);\n        }\n      };\n    }\n  }\n\n  /**\n   * @param {Iterator<T>[]} iterators list of iterators to append to\n   * @returns {void}\n   */\n  _appendIterators(iterators) {\n    if (this._unsortedItems.size > 0) iterators.push(this._unsortedItems[Symbol.iterator]());\n    for (const key of this._keys) {\n      const entry = this._map.get(key);\n      if (this._leaf) {\n        const leafEntry = /** @type {SortableSet<T>} */entry;\n        const iterator = leafEntry[Symbol.iterator]();\n        iterators.push(iterator);\n      } else {\n        const nodeEntry = /** @type {LazyBucketSortedSet<T, any>} */entry;\n        nodeEntry._appendIterators(iterators);\n      }\n    }\n  }\n\n  /**\n   * @returns {Iterator<T>} the iterator\n   */\n  [Symbol.iterator]() {\n    const iterators = [];\n    this._appendIterators(iterators);\n    iterators.reverse();\n    let currentIterator = iterators.pop();\n    return {\n      next: () => {\n        const res = currentIterator.next();\n        if (res.done) {\n          if (iterators.length === 0) return res;\n          currentIterator = iterators.pop();\n          return currentIterator.next();\n        }\n        return res;\n      }\n    };\n  }\n}\nmodule.exports = LazyBucketSortedSet;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}