{"ast":null,"code":"'use strict';\n\nconst BB = require('bluebird');\nconst contentPath = require('./path');\nconst fixOwner = require('../util/fix-owner');\nconst fs = require('graceful-fs');\nconst moveFile = require('../util/move-file');\nconst PassThrough = require('stream').PassThrough;\nconst path = require('path');\nconst pipe = BB.promisify(require('mississippi').pipe);\nconst rimraf = BB.promisify(require('rimraf'));\nconst ssri = require('ssri');\nconst to = require('mississippi').to;\nconst uniqueFilename = require('unique-filename');\nconst Y = require('../util/y.js');\nconst writeFileAsync = BB.promisify(fs.writeFile);\nmodule.exports = write;\nfunction write(cache, data, opts) {\n  opts = opts || {};\n  if (opts.algorithms && opts.algorithms.length > 1) {\n    throw new Error(Y`opts.algorithms only supports a single algorithm for now`);\n  }\n  if (typeof opts.size === 'number' && data.length !== opts.size) {\n    return BB.reject(sizeError(opts.size, data.length));\n  }\n  const sri = ssri.fromData(data, {\n    algorithms: opts.algorithms\n  });\n  if (opts.integrity && !ssri.checkData(data, opts.integrity, opts)) {\n    return BB.reject(checksumError(opts.integrity, sri));\n  }\n  return BB.using(makeTmp(cache, opts), tmp => writeFileAsync(tmp.target, data, {\n    flag: 'wx'\n  }).then(() => moveToDestination(tmp, cache, sri, opts))).then(() => ({\n    integrity: sri,\n    size: data.length\n  }));\n}\nmodule.exports.stream = writeStream;\nfunction writeStream(cache, opts) {\n  opts = opts || {};\n  const inputStream = new PassThrough();\n  let inputErr = false;\n  function errCheck() {\n    if (inputErr) {\n      throw inputErr;\n    }\n  }\n  let allDone;\n  const ret = to((c, n, cb) => {\n    if (!allDone) {\n      allDone = handleContent(inputStream, cache, opts, errCheck);\n    }\n    inputStream.write(c, n, cb);\n  }, cb => {\n    inputStream.end(() => {\n      if (!allDone) {\n        const e = new Error(Y`Cache input stream was empty`);\n        e.code = 'ENODATA';\n        return ret.emit('error', e);\n      }\n      allDone.then(res => {\n        res.integrity && ret.emit('integrity', res.integrity);\n        res.size !== null && ret.emit('size', res.size);\n        cb();\n      }, e => {\n        ret.emit('error', e);\n      });\n    });\n  });\n  ret.once('error', e => {\n    inputErr = e;\n  });\n  return ret;\n}\nfunction handleContent(inputStream, cache, opts, errCheck) {\n  return BB.using(makeTmp(cache, opts), tmp => {\n    errCheck();\n    return pipeToTmp(inputStream, cache, tmp.target, opts, errCheck).then(res => {\n      return moveToDestination(tmp, cache, res.integrity, opts, errCheck).then(() => res);\n    });\n  });\n}\nfunction pipeToTmp(inputStream, cache, tmpTarget, opts, errCheck) {\n  return BB.resolve().then(() => {\n    let integrity;\n    let size;\n    const hashStream = ssri.integrityStream({\n      integrity: opts.integrity,\n      algorithms: opts.algorithms,\n      size: opts.size\n    }).on('integrity', s => {\n      integrity = s;\n    }).on('size', s => {\n      size = s;\n    });\n    const outStream = fs.createWriteStream(tmpTarget, {\n      flags: 'wx'\n    });\n    errCheck();\n    return pipe(inputStream, hashStream, outStream).then(() => {\n      return {\n        integrity,\n        size\n      };\n    }).catch(err => {\n      return rimraf(tmpTarget).then(() => {\n        throw err;\n      });\n    });\n  });\n}\nfunction makeTmp(cache, opts) {\n  const tmpTarget = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix);\n  return fixOwner.mkdirfix(cache, path.dirname(tmpTarget)).then(() => ({\n    target: tmpTarget,\n    moved: false\n  })).disposer(tmp => !tmp.moved && rimraf(tmp.target));\n}\nfunction moveToDestination(tmp, cache, sri, opts, errCheck) {\n  errCheck && errCheck();\n  const destination = contentPath(cache, sri);\n  const destDir = path.dirname(destination);\n  return fixOwner.mkdirfix(cache, destDir).then(() => {\n    errCheck && errCheck();\n    return moveFile(tmp.target, destination);\n  }).then(() => {\n    errCheck && errCheck();\n    tmp.moved = true;\n    return fixOwner.chownr(cache, destination);\n  });\n}\nfunction sizeError(expected, found) {\n  var err = new Error(Y`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`);\n  err.expected = expected;\n  err.found = found;\n  err.code = 'EBADSIZE';\n  return err;\n}\nfunction checksumError(expected, found) {\n  var err = new Error(Y`Integrity check failed:\n  Wanted: ${expected}\n   Found: ${found}`);\n  err.code = 'EINTEGRITY';\n  err.expected = expected;\n  err.found = found;\n  return err;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}