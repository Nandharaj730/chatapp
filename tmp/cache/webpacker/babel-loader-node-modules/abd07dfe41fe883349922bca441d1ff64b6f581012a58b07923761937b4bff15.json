{"ast":null,"code":"/*\nMIT License http://www.opensource.org/licenses/mit-license.php\nAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nconst util = require(\"util\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst intersect = require(\"./util/SetHelpers\").intersect;\nconst GraphHelpers = require(\"./GraphHelpers\");\nconst Entrypoint = require(\"./Entrypoint\");\nlet debugId = 1000;\nconst ERR_CHUNK_ENTRY = \"Chunk.entry was removed. Use hasRuntime()\";\nconst ERR_CHUNK_INITIAL = \"Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\";\n\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./ModuleReason\")} ModuleReason */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n/**\n *  @typedef {Object} WithId an object who has an id property *\n *  @property {string | number} id the id of the object\n */\n\n/**\n * Compare two Modules based on their ids for sorting\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} sort value\n */\n\n// TODO use @callback\n/** @typedef {(a: Module, b: Module) => -1|0|1} ModuleSortPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {(c: Chunk) => boolean} ChunkFilterPredicate */\n\nconst sortModuleById = (a, b) => {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n\n/**\n * Compare two ChunkGroups based on their ids for sorting\n * @param {ChunkGroup} a chunk group\n * @param {ChunkGroup} b chunk group\n * @returns {-1|0|1} sort value\n */\nconst sortChunkGroupById = (a, b) => {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n\n/**\n * Compare two Identifiables , based on their ids for sorting\n * @param {Module} a first object with ident fn\n * @param {Module} b second object with ident fn\n * @returns {-1|0|1} The order number of the sort\n */\nconst sortByIdentifier = (a, b) => {\n  if (a.identifier() > b.identifier()) return 1;\n  if (a.identifier() < b.identifier()) return -1;\n  return 0;\n};\n\n/**\n * @returns {string} a concatenation of module identifiers sorted\n * @param {SortableSet} set to pull module identifiers from\n */\nconst getModulesIdent = set => {\n  set.sort();\n  let str = \"\";\n  for (const m of set) {\n    str += m.identifier() + \"#\";\n  }\n  return str;\n};\n\n/**\n * @template T\n * @param {SortableSet<T>} set the sortable set to convert to array\n * @returns {Array<T>} the array returned from Array.from(set)\n */\nconst getArray = set => Array.from(set);\n\n/**\n * @param {SortableSet<Module>} set the sortable Set to get the count/size of\n * @returns {number} the size of the modules\n */\nconst getModulesSize = set => {\n  let size = 0;\n  for (const module of set) {\n    size += module.size();\n  }\n  return size;\n};\n\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\nclass Chunk {\n  /**\n   * @param {string=} name of chunk being created, is optional (for subclasses)\n   */\n  constructor(name) {\n    /** @type {number | null} */\n    this.id = null;\n    /** @type {number[] | null} */\n    this.ids = null;\n    /** @type {number} */\n    this.debugId = debugId++;\n    /** @type {string} */\n    this.name = name;\n    /** @type {boolean} */\n    this.preventIntegration = false;\n    /** @type {Module=} */\n    this.entryModule = undefined;\n    /** @private @type {SortableSet<Module>} */\n    this._modules = new SortableSet(undefined, sortByIdentifier);\n    /** @type {string?} */\n    this.filenameTemplate = undefined;\n    /** @private @type {SortableSet<ChunkGroup>} */\n    this._groups = new SortableSet(undefined, sortChunkGroupById);\n    /** @type {string[]} */\n    this.files = [];\n    /** @type {boolean} */\n    this.rendered = false;\n    /** @type {string=} */\n    this.hash = undefined;\n    /** @type {Object} */\n    this.contentHash = Object.create(null);\n    /** @type {string=} */\n    this.renderedHash = undefined;\n    /** @type {string=} */\n    this.chunkReason = undefined;\n    /** @type {boolean} */\n    this.extraAsync = false;\n    this.removedModules = undefined;\n  }\n\n  /**\n   * @deprecated Chunk.entry has been deprecated. Please use .hasRuntime() instead\n   * @returns {never} Throws an error trying to access this property\n   */\n  get entry() {\n    throw new Error(ERR_CHUNK_ENTRY);\n  }\n\n  /**\n   * @deprecated .entry has been deprecated. Please use .hasRuntime() instead\n   * @param {never} data The data that was attempting to be set\n   * @returns {never} Throws an error trying to access this property\n   */\n  set entry(data) {\n    throw new Error(ERR_CHUNK_ENTRY);\n  }\n\n  /**\n   * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n   * @returns {never} Throws an error trying to access this property\n   */\n  get initial() {\n    throw new Error(ERR_CHUNK_INITIAL);\n  }\n\n  /**\n   * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n   * @param {never} data The data attempting to be set\n   * @returns {never} Throws an error trying to access this property\n   */\n  set initial(data) {\n    throw new Error(ERR_CHUNK_INITIAL);\n  }\n\n  /**\n   * @returns {boolean} whether or not the Chunk will have a runtime\n   */\n  hasRuntime() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup.isInitial() && chunkGroup instanceof Entrypoint && chunkGroup.getRuntimeChunk() === this) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @returns {boolean} whether or not this chunk can be an initial chunk\n   */\n  canBeInitial() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup.isInitial()) return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns {boolean} whether this chunk can only be an initial chunk\n   */\n  isOnlyInitial() {\n    if (this._groups.size <= 0) return false;\n    for (const chunkGroup of this._groups) {\n      if (!chunkGroup.isInitial()) return false;\n    }\n    return true;\n  }\n\n  /**\n   * @returns {boolean} if this chunk contains the entry module\n   */\n  hasEntryModule() {\n    return !!this.entryModule;\n  }\n\n  /**\n   * @param {Module} module the module that will be added to this chunk.\n   * @returns {boolean} returns true if the chunk doesn't have the module and it was added\n   */\n  addModule(module) {\n    if (!this._modules.has(module)) {\n      this._modules.add(module);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @param {Module} module the module that will be removed from this chunk\n   * @returns {boolean} returns true if chunk exists and is successfully deleted\n   */\n  removeModule(module) {\n    if (this._modules.delete(module)) {\n      module.removeChunk(this);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @param {Module[]} modules the new modules to be set\n   * @returns {void} set new modules to this chunk and return nothing\n   */\n  setModules(modules) {\n    this._modules = new SortableSet(modules, sortByIdentifier);\n  }\n\n  /**\n   * @returns {number} the amount of modules in chunk\n   */\n  getNumberOfModules() {\n    return this._modules.size;\n  }\n\n  /**\n   * @returns {SortableSet} return the modules SortableSet for this chunk\n   */\n  get modulesIterable() {\n    return this._modules;\n  }\n\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n   * @returns {boolean} returns true if chunk is not apart of chunkGroup and is added successfully\n   */\n  addGroup(chunkGroup) {\n    if (this._groups.has(chunkGroup)) return false;\n    this._groups.add(chunkGroup);\n    return true;\n  }\n\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n   * @returns {boolean} returns true if chunk does exist in chunkGroup and is removed\n   */\n  removeGroup(chunkGroup) {\n    if (!this._groups.has(chunkGroup)) return false;\n    this._groups.delete(chunkGroup);\n    return true;\n  }\n\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup to check\n   * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n   */\n  isInGroup(chunkGroup) {\n    return this._groups.has(chunkGroup);\n  }\n\n  /**\n   * @returns {number} the amount of groups said chunk is in\n   */\n  getNumberOfGroups() {\n    return this._groups.size;\n  }\n\n  /**\n   * @returns {SortableSet<ChunkGroup>} the chunkGroups that said chunk is referenced in\n   */\n  get groupsIterable() {\n    return this._groups;\n  }\n\n  /**\n   * @param {Chunk} otherChunk the chunk to compare itself with\n   * @returns {-1|0|1} this is a comparitor function like sort and returns -1, 0, or 1 based on sort order\n   */\n  compareTo(otherChunk) {\n    if (this.name && !otherChunk.name) return -1;\n    if (!this.name && otherChunk.name) return 1;\n    if (this.name < otherChunk.name) return -1;\n    if (this.name > otherChunk.name) return 1;\n    if (this._modules.size > otherChunk._modules.size) return -1;\n    if (this._modules.size < otherChunk._modules.size) return 1;\n    this._modules.sort();\n    otherChunk._modules.sort();\n    const a = this._modules[Symbol.iterator]();\n    const b = otherChunk._modules[Symbol.iterator]();\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const aItem = a.next();\n      if (aItem.done) return 0;\n      const bItem = b.next();\n      const aModuleIdentifier = aItem.value.identifier();\n      const bModuleIdentifier = bItem.value.identifier();\n      if (aModuleIdentifier < bModuleIdentifier) return -1;\n      if (aModuleIdentifier > bModuleIdentifier) return 1;\n    }\n  }\n\n  /**\n   * @param {Module} module Module to check\n   * @returns {boolean} returns true if module does exist in this chunk\n   */\n  containsModule(module) {\n    return this._modules.has(module);\n  }\n\n  /**\n   * @returns {Module[]} an array of modules (do not modify)\n   */\n  getModules() {\n    return this._modules.getFromCache(getArray);\n  }\n  getModulesIdent() {\n    return this._modules.getFromUnorderedCache(getModulesIdent);\n  }\n\n  /**\n   * @param {string=} reason reason why chunk is removed\n   * @returns {void}\n   */\n  remove(reason) {\n    // cleanup modules\n    // Array.from is used here to create a clone, because removeChunk modifies this._modules\n    for (const module of Array.from(this._modules)) {\n      module.removeChunk(this);\n    }\n    for (const chunkGroup of this._groups) {\n      chunkGroup.removeChunk(this);\n    }\n  }\n\n  /**\n   *\n   * @param {Module} module module to move\n   * @param {Chunk} otherChunk other chunk to move it to\n   * @returns {void}\n   */\n  moveModule(module, otherChunk) {\n    GraphHelpers.disconnectChunkAndModule(this, module);\n    GraphHelpers.connectChunkAndModule(otherChunk, module);\n    module.rewriteChunkInReasons(this, [otherChunk]);\n  }\n\n  /**\n   *\n   * @param {Chunk} otherChunk the chunk to integrate with\n   * @param {string} reason reason why the module is being integrated\n   * @returns {boolean} returns true or false if integration succeeds or fails\n   */\n  integrate(otherChunk, reason) {\n    if (!this.canBeIntegrated(otherChunk)) {\n      return false;\n    }\n\n    // Pick a new name for the integrated chunk\n    if (this.name && otherChunk.name) {\n      if (this.hasEntryModule() === otherChunk.hasEntryModule()) {\n        // When both chunks have entry modules or none have one, use\n        // shortest name\n        if (this.name.length !== otherChunk.name.length) {\n          this.name = this.name.length < otherChunk.name.length ? this.name : otherChunk.name;\n        } else {\n          this.name = this.name < otherChunk.name ? this.name : otherChunk.name;\n        }\n      } else if (otherChunk.hasEntryModule()) {\n        // Pick the name of the chunk with the entry module\n        this.name = otherChunk.name;\n      }\n    } else if (otherChunk.name) {\n      this.name = otherChunk.name;\n    }\n\n    // Array.from is used here to create a clone, because moveModule modifies otherChunk._modules\n    for (const module of Array.from(otherChunk._modules)) {\n      otherChunk.moveModule(module, this);\n    }\n    otherChunk._modules.clear();\n    if (otherChunk.entryModule) {\n      this.entryModule = otherChunk.entryModule;\n    }\n    for (const chunkGroup of otherChunk._groups) {\n      chunkGroup.replaceChunk(otherChunk, this);\n      this.addGroup(chunkGroup);\n    }\n    otherChunk._groups.clear();\n    return true;\n  }\n\n  /**\n   * @param {Chunk} newChunk the new chunk that will be split out of the current chunk\n   * @returns {void}\n   */\n  split(newChunk) {\n    for (const chunkGroup of this._groups) {\n      chunkGroup.insertChunk(newChunk, this);\n      newChunk.addGroup(chunkGroup);\n    }\n  }\n  isEmpty() {\n    return this._modules.size === 0;\n  }\n  updateHash(hash) {\n    hash.update(`${this.id} `);\n    hash.update(this.ids ? this.ids.join(\",\") : \"\");\n    hash.update(`${this.name || \"\"} `);\n    for (const m of this._modules) {\n      hash.update(m.hash);\n    }\n  }\n  canBeIntegrated(otherChunk) {\n    if (this.preventIntegration || otherChunk.preventIntegration) {\n      return false;\n    }\n\n    /**\n     * @param {Chunk} a chunk\n     * @param {Chunk} b chunk\n     * @returns {boolean} true, if a is always available when b is reached\n     */\n    const isAvailable = (a, b) => {\n      const queue = new Set(b.groupsIterable);\n      for (const chunkGroup of queue) {\n        if (a.isInGroup(chunkGroup)) continue;\n        if (chunkGroup.isInitial()) return false;\n        for (const parent of chunkGroup.parentsIterable) {\n          queue.add(parent);\n        }\n      }\n      return true;\n    };\n    const selfHasRuntime = this.hasRuntime();\n    const otherChunkHasRuntime = otherChunk.hasRuntime();\n    if (selfHasRuntime !== otherChunkHasRuntime) {\n      if (selfHasRuntime) {\n        return isAvailable(this, otherChunk);\n      } else if (otherChunkHasRuntime) {\n        return isAvailable(otherChunk, this);\n      } else {\n        return false;\n      }\n    }\n    if (this.hasEntryModule() || otherChunk.hasEntryModule()) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   *\n   * @param {number} size the size\n   * @param {Object} options the options passed in\n   * @returns {number} the multiplier returned\n   */\n  addMultiplierAndOverhead(size, options) {\n    const overhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n    const multiplicator = this.canBeInitial() ? options.entryChunkMultiplicator || 10 : 1;\n    return size * multiplicator + overhead;\n  }\n\n  /**\n   * @returns {number} the size of all modules\n   */\n  modulesSize() {\n    return this._modules.getFromUnorderedCache(getModulesSize);\n  }\n\n  /**\n   * @param {Object} options the size display options\n   * @returns {number} the chunk size\n   */\n  size() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.addMultiplierAndOverhead(this.modulesSize(), options);\n  }\n\n  /**\n   * @param {Chunk} otherChunk the other chunk\n   * @param {TODO} options the options for this function\n   * @returns {number | false} the size, or false if it can't be integrated\n   */\n  integratedSize(otherChunk, options) {\n    // Chunk if it's possible to integrate this chunk\n    if (!this.canBeIntegrated(otherChunk)) {\n      return false;\n    }\n    let integratedModulesSize = this.modulesSize();\n    // only count modules that do not exist in this chunk!\n    for (const otherModule of otherChunk._modules) {\n      if (!this._modules.has(otherModule)) {\n        integratedModulesSize += otherModule.size();\n      }\n    }\n    return this.addMultiplierAndOverhead(integratedModulesSize, options);\n  }\n\n  /**\n   * @param {function(Module, Module): -1|0|1=} sortByFn a predicate function used to sort modules\n   * @returns {void}\n   */\n  sortModules(sortByFn) {\n    this._modules.sortWith(sortByFn || sortModuleById);\n  }\n  sortItems() {\n    this.sortModules();\n  }\n\n  /**\n   * @returns {Set<Chunk>} a set of all the async chunks\n   */\n  getAllAsyncChunks() {\n    const queue = new Set();\n    const chunks = new Set();\n    const initialChunks = intersect(Array.from(this.groupsIterable, g => new Set(g.chunks)));\n    for (const chunkGroup of this.groupsIterable) {\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        if (!initialChunks.has(chunk)) {\n          chunks.add(chunk);\n        }\n      }\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    return chunks;\n  }\n\n  /**\n   * @typedef {Object} ChunkMaps\n   * @property {Record<string|number, string>} hash\n   * @property {Record<string|number, Record<string, string>>} contentHash\n   * @property {Record<string|number, string>} name\n   */\n\n  /**\n   * @param {boolean} realHash should the full hash or the rendered hash be used\n   * @returns {ChunkMaps} the chunk map information\n   */\n  getChunkMaps(realHash) {\n    /** @type {Record<string|number, string>} */\n    const chunkHashMap = Object.create(null);\n    /** @type {Record<string|number, Record<string, string>>} */\n    const chunkContentHashMap = Object.create(null);\n    /** @type {Record<string|number, string>} */\n    const chunkNameMap = Object.create(null);\n    for (const chunk of this.getAllAsyncChunks()) {\n      chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n      for (const key of Object.keys(chunk.contentHash)) {\n        if (!chunkContentHashMap[key]) {\n          chunkContentHashMap[key] = Object.create(null);\n        }\n        chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n      }\n      if (chunk.name) {\n        chunkNameMap[chunk.id] = chunk.name;\n      }\n    }\n    return {\n      hash: chunkHashMap,\n      contentHash: chunkContentHashMap,\n      name: chunkNameMap\n    };\n  }\n\n  /**\n   * @returns {Record<string, Set<TODO>[]>} a record object of names to lists of child ids(?)\n   */\n  getChildIdsByOrders() {\n    const lists = new Map();\n    for (const group of this.groupsIterable) {\n      if (group.chunks[group.chunks.length - 1] === this) {\n        for (const childGroup of group.childrenIterable) {\n          // TODO webpack 5 remove this check for options\n          if (typeof childGroup.options === \"object\") {\n            for (const key of Object.keys(childGroup.options)) {\n              if (key.endsWith(\"Order\")) {\n                const name = key.substr(0, key.length - \"Order\".length);\n                let list = lists.get(name);\n                if (list === undefined) lists.set(name, list = []);\n                list.push({\n                  order: childGroup.options[key],\n                  group: childGroup\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n    const result = Object.create(null);\n    for (const _ref of lists) {\n      var _ref2 = _slicedToArray(_ref, 2);\n      const name = _ref2[0];\n      const list = _ref2[1];\n      list.sort((a, b) => {\n        const cmp = b.order - a.order;\n        if (cmp !== 0) return cmp;\n        // TODO webpack 5 remove this check of compareTo\n        if (a.group.compareTo) {\n          return a.group.compareTo(b.group);\n        }\n        return 0;\n      });\n      result[name] = Array.from(list.reduce((set, item) => {\n        for (const chunk of item.group.chunks) {\n          set.add(chunk.id);\n        }\n        return set;\n      }, new Set()));\n    }\n    return result;\n  }\n  getChildIdsByOrdersMap(includeDirectChildren) {\n    const chunkMaps = Object.create(null);\n    const addChildIdsByOrdersToMap = chunk => {\n      const data = chunk.getChildIdsByOrders();\n      for (const key of Object.keys(data)) {\n        let chunkMap = chunkMaps[key];\n        if (chunkMap === undefined) {\n          chunkMaps[key] = chunkMap = Object.create(null);\n        }\n        chunkMap[chunk.id] = data[key];\n      }\n    };\n    if (includeDirectChildren) {\n      const chunks = new Set();\n      for (const chunkGroup of this.groupsIterable) {\n        for (const chunk of chunkGroup.chunks) {\n          chunks.add(chunk);\n        }\n      }\n      for (const chunk of chunks) {\n        addChildIdsByOrdersToMap(chunk);\n      }\n    }\n    for (const chunk of this.getAllAsyncChunks()) {\n      addChildIdsByOrdersToMap(chunk);\n    }\n    return chunkMaps;\n  }\n\n  /**\n   * @typedef {Object} ChunkModuleMaps\n   * @property {Record<string|number, (string|number)[]>} id\n   * @property {Record<string|number, string>} hash\n   */\n\n  /**\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\n   * @returns {ChunkModuleMaps} module map information\n   */\n  getChunkModuleMaps(filterFn) {\n    /** @type {Record<string|number, (string|number)[]>} */\n    const chunkModuleIdMap = Object.create(null);\n    /** @type {Record<string|number, string>} */\n    const chunkModuleHashMap = Object.create(null);\n    for (const chunk of this.getAllAsyncChunks()) {\n      /** @type {(string|number)[]} */\n      let array;\n      for (const module of chunk.modulesIterable) {\n        if (filterFn(module)) {\n          if (array === undefined) {\n            array = [];\n            chunkModuleIdMap[chunk.id] = array;\n          }\n          array.push(module.id);\n          chunkModuleHashMap[module.id] = module.renderedHash;\n        }\n      }\n      if (array !== undefined) {\n        array.sort();\n      }\n    }\n    return {\n      id: chunkModuleIdMap,\n      hash: chunkModuleHashMap\n    };\n  }\n\n  /**\n   *\n   * @param {function(Module): boolean} filterFn predicate function used to filter modules\n   * @param {function(Chunk): boolean} filterChunkFn predicate function used to filter chunks\n   * @returns {boolean} return true if module exists in graph\n   */\n  hasModuleInGraph(filterFn, filterChunkFn) {\n    const queue = new Set(this.groupsIterable);\n    const chunksProcessed = new Set();\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        if (!chunksProcessed.has(chunk)) {\n          chunksProcessed.add(chunk);\n          if (!filterChunkFn || filterChunkFn(chunk)) {\n            for (const module of chunk.modulesIterable) {\n              if (filterFn(module)) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    return false;\n  }\n  toString() {\n    return `Chunk[${Array.from(this._modules).join()}]`;\n  }\n}\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"forEachModule\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @this {Chunk}\n   * @typedef {function(any, any, Set<any>): void} ForEachModuleCallback\n   * @param {ForEachModuleCallback} fn Callback function\n   * @returns {void}\n   */\n  function (fn) {\n    this._modules.forEach(fn);\n  }, \"Chunk.forEachModule: Use for(const module of chunk.modulesIterable) instead\")\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"mapModules\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @this {Chunk}\n   * @typedef {function(any, number): any} MapModulesCallback\n   * @param {MapModulesCallback} fn Callback function\n   * @returns {TODO[]} result of mapped modules\n   */\n  function (fn) {\n    return Array.from(this._modules, fn);\n  }, \"Chunk.mapModules: Use Array.from(chunk.modulesIterable, fn) instead\")\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"chunks\", {\n  configurable: false,\n  get() {\n    throw new Error(\"Chunk.chunks: Use ChunkGroup.getChildren() instead\");\n  },\n  set() {\n    throw new Error(\"Chunk.chunks: Use ChunkGroup.add/removeChild() instead\");\n  }\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"parents\", {\n  configurable: false,\n  get() {\n    throw new Error(\"Chunk.parents: Use ChunkGroup.getParents() instead\");\n  },\n  set() {\n    throw new Error(\"Chunk.parents: Use ChunkGroup.add/removeParent() instead\");\n  }\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"blocks\", {\n  configurable: false,\n  get() {\n    throw new Error(\"Chunk.blocks: Use ChunkGroup.getBlocks() instead\");\n  },\n  set() {\n    throw new Error(\"Chunk.blocks: Use ChunkGroup.add/removeBlock() instead\");\n  }\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"entrypoints\", {\n  configurable: false,\n  get() {\n    throw new Error(\"Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead\");\n  },\n  set() {\n    throw new Error(\"Chunk.entrypoints: Use Chunks.addGroup instead\");\n  }\n});\nmodule.exports = Chunk;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}