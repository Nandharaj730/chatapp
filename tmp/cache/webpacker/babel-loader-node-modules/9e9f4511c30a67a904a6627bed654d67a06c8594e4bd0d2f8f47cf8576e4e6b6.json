{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nconst Template = require(\"../Template\");\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../MainTemplate\")} MainTemplate */\n\n// Get all wasm modules\nconst getAllWasmModules = chunk => {\n  const wasmModules = chunk.getAllAsyncChunks();\n  const array = [];\n  for (const chunk of wasmModules) {\n    for (const m of chunk.modulesIterable) {\n      if (m.type.startsWith(\"webassembly\")) {\n        array.push(m);\n      }\n    }\n  }\n  return array;\n};\n\n/**\n * generates the import object function for a module\n * @param {Module} module the module\n * @param {boolean} mangle mangle imports\n * @returns {string} source code\n */\nconst generateImportObject = (module, mangle) => {\n  const waitForInstances = new Map();\n  const properties = [];\n  const usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(module, mangle);\n  for (const usedDep of usedWasmDependencies) {\n    const dep = usedDep.dependency;\n    const importedModule = dep.module;\n    const exportName = dep.name;\n    const usedName = importedModule && importedModule.isUsed(exportName);\n    const description = dep.description;\n    const direct = dep.onlyDirectImport;\n    const module = usedDep.module;\n    const name = usedDep.name;\n    if (direct) {\n      const instanceVar = `m${waitForInstances.size}`;\n      waitForInstances.set(instanceVar, importedModule.id);\n      properties.push({\n        module,\n        name,\n        value: `${instanceVar}[${JSON.stringify(usedName)}]`\n      });\n    } else {\n      const params = description.signature.params.map((param, k) => \"p\" + k + param.valtype);\n      const mod = `installedModules[${JSON.stringify(importedModule.id)}]`;\n      const func = `${mod}.exports[${JSON.stringify(usedName)}]`;\n      properties.push({\n        module,\n        name,\n        value: Template.asString([(importedModule.type.startsWith(\"webassembly\") ? `${mod} ? ${func} : ` : \"\") + `function(${params}) {`, Template.indent([`return ${func}(${params});`]), \"}\"])\n      });\n    }\n  }\n  let importObject;\n  if (mangle) {\n    importObject = [\"return {\", Template.indent([properties.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")]), \"};\"];\n  } else {\n    const propertiesByModule = new Map();\n    for (const p of properties) {\n      let list = propertiesByModule.get(p.module);\n      if (list === undefined) {\n        propertiesByModule.set(p.module, list = []);\n      }\n      list.push(p);\n    }\n    importObject = [\"return {\", Template.indent([Array.from(propertiesByModule, _ref => {\n      let _ref2 = _slicedToArray(_ref, 2),\n        module = _ref2[0],\n        list = _ref2[1];\n      return Template.asString([`${JSON.stringify(module)}: {`, Template.indent([list.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")]), \"}\"]);\n    }).join(\",\\n\")]), \"};\"];\n  }\n  if (waitForInstances.size === 1) {\n    const moduleId = Array.from(waitForInstances.values())[0];\n    const promise = `installedWasmModules[${JSON.stringify(moduleId)}]`;\n    const variable = Array.from(waitForInstances.keys())[0];\n    return Template.asString([`${JSON.stringify(module.id)}: function() {`, Template.indent([`return promiseResolve().then(function() { return ${promise}; }).then(function(${variable}) {`, Template.indent(importObject), \"});\"]), \"},\"]);\n  } else if (waitForInstances.size > 0) {\n    const promises = Array.from(waitForInstances.values(), id => `installedWasmModules[${JSON.stringify(id)}]`).join(\", \");\n    const variables = Array.from(waitForInstances.keys(), (name, i) => `${name} = array[${i}]`).join(\", \");\n    return Template.asString([`${JSON.stringify(module.id)}: function() {`, Template.indent([`return promiseResolve().then(function() { return Promise.all([${promises}]); }).then(function(array) {`, Template.indent([`var ${variables};`, ...importObject]), \"});\"]), \"},\"]);\n  } else {\n    return Template.asString([`${JSON.stringify(module.id)}: function() {`, Template.indent(importObject), \"},\"]);\n  }\n};\nclass WasmMainTemplatePlugin {\n  constructor(_ref3) {\n    let generateLoadBinaryCode = _ref3.generateLoadBinaryCode,\n      supportsStreaming = _ref3.supportsStreaming,\n      mangleImports = _ref3.mangleImports;\n    this.generateLoadBinaryCode = generateLoadBinaryCode;\n    this.supportsStreaming = supportsStreaming;\n    this.mangleImports = mangleImports;\n  }\n\n  /**\n   * @param {MainTemplate} mainTemplate main template\n   * @returns {void}\n   */\n  apply(mainTemplate) {\n    mainTemplate.hooks.localVars.tap(\"WasmMainTemplatePlugin\", (source, chunk) => {\n      const wasmModules = getAllWasmModules(chunk);\n      if (wasmModules.length === 0) return source;\n      const importObjects = wasmModules.map(module => {\n        return generateImportObject(module, this.mangleImports);\n      });\n      return Template.asString([source, \"\", \"// object to store loaded and loading wasm modules\", \"var installedWasmModules = {};\", \"\",\n      // This function is used to delay reading the installed wasm module promises\n      // by a microtask. Sorting them doesn't help because there are egdecases where\n      // sorting is not possible (modules splitted into different chunks).\n      // So we not even trying and solve this by a microtask delay.\n      \"function promiseResolve() { return Promise.resolve(); }\", \"\", \"var wasmImportObjects = {\", Template.indent(importObjects), \"};\"]);\n    });\n    mainTemplate.hooks.requireEnsure.tap(\"WasmMainTemplatePlugin\", (source, chunk, hash) => {\n      const webassemblyModuleFilename = mainTemplate.outputOptions.webassemblyModuleFilename;\n      const chunkModuleMaps = chunk.getChunkModuleMaps(m => m.type.startsWith(\"webassembly\"));\n      if (Object.keys(chunkModuleMaps.id).length === 0) return source;\n      const wasmModuleSrcPath = mainTemplate.getAssetPath(JSON.stringify(webassemblyModuleFilename), {\n        hash: `\" + ${mainTemplate.renderCurrentHashCode(hash)} + \"`,\n        hashWithLength: length => `\" + ${mainTemplate.renderCurrentHashCode(hash, length)} + \"`,\n        module: {\n          id: '\" + wasmModuleId + \"',\n          hash: `\" + ${JSON.stringify(chunkModuleMaps.hash)}[wasmModuleId] + \"`,\n          hashWithLength(length) {\n            const shortChunkHashMap = Object.create(null);\n            for (const wasmModuleId of Object.keys(chunkModuleMaps.hash)) {\n              if (typeof chunkModuleMaps.hash[wasmModuleId] === \"string\") {\n                shortChunkHashMap[wasmModuleId] = chunkModuleMaps.hash[wasmModuleId].substr(0, length);\n              }\n            }\n            return `\" + ${JSON.stringify(shortChunkHashMap)}[wasmModuleId] + \"`;\n          }\n        }\n      });\n      const createImportObject = content => this.mangleImports ? `{ ${JSON.stringify(WebAssemblyUtils.MANGLED_MODULE)}: ${content} }` : content;\n      return Template.asString([source, \"\", \"// Fetch + compile chunk loading for webassembly\", \"\", `var wasmModules = ${JSON.stringify(chunkModuleMaps.id)}[chunkId] || [];`, \"\", \"wasmModules.forEach(function(wasmModuleId) {\", Template.indent([\"var installedWasmModuleData = installedWasmModules[wasmModuleId];\", \"\", '// a Promise means \"currently loading\" or \"already loaded\".', \"if(installedWasmModuleData)\", Template.indent([\"promises.push(installedWasmModuleData);\"]), \"else {\", Template.indent([`var importObject = wasmImportObjects[wasmModuleId]();`, `var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)};`, \"var promise;\", this.supportsStreaming ? Template.asString([\"if(importObject instanceof Promise && typeof WebAssembly.compileStreaming === 'function') {\", Template.indent([\"promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {\", Template.indent([`return WebAssembly.instantiate(items[0], ${createImportObject(\"items[1]\")});`]), \"});\"]), \"} else if(typeof WebAssembly.instantiateStreaming === 'function') {\", Template.indent([`promise = WebAssembly.instantiateStreaming(req, ${createImportObject(\"importObject\")});`])]) : Template.asString([\"if(importObject instanceof Promise) {\", Template.indent([\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\", \"promise = Promise.all([\", Template.indent([\"bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),\", \"importObject\"]), \"]).then(function(items) {\", Template.indent([`return WebAssembly.instantiate(items[0], ${createImportObject(\"items[1]\")});`]), \"});\"])]), \"} else {\", Template.indent([\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\", \"promise = bytesPromise.then(function(bytes) {\", Template.indent([`return WebAssembly.instantiate(bytes, ${createImportObject(\"importObject\")});`]), \"});\"]), \"}\", \"promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {\", Template.indent([`return ${mainTemplate.requireFn}.w[wasmModuleId] = (res.instance || res).exports;`]), \"}));\"]), \"}\"]), \"});\"]);\n    });\n    mainTemplate.hooks.requireExtensions.tap(\"WasmMainTemplatePlugin\", (source, chunk) => {\n      if (!chunk.hasModuleInGraph(m => m.type.startsWith(\"webassembly\"))) {\n        return source;\n      }\n      return Template.asString([source, \"\", \"// object with all WebAssembly.instance exports\", `${mainTemplate.requireFn}.w = {};`]);\n    });\n    mainTemplate.hooks.hash.tap(\"WasmMainTemplatePlugin\", hash => {\n      hash.update(\"WasmMainTemplatePlugin\");\n      hash.update(\"2\");\n    });\n  }\n}\nmodule.exports = WasmMainTemplatePlugin;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}