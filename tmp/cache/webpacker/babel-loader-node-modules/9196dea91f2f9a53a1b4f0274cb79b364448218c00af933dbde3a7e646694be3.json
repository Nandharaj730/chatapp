{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {false | true | string[]} UsedExports */\nconst addToSet = (a, b) => {\n  for (const item of b) {\n    if (!a.includes(item)) a.push(item);\n  }\n  return a;\n};\nconst isSubset = (biggerSet, subset) => {\n  if (biggerSet === true) return true;\n  if (subset === true) return false;\n  return subset.every(item => biggerSet.indexOf(item) >= 0);\n};\nclass FlagDependencyUsagePlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"FlagDependencyUsagePlugin\", compilation => {\n      compilation.hooks.optimizeDependencies.tap(\"FlagDependencyUsagePlugin\", modules => {\n        const processModule = (module, usedExports) => {\n          module.used = true;\n          if (module.usedExports === true) return;\n          if (usedExports === true) {\n            module.usedExports = true;\n          } else if (Array.isArray(usedExports)) {\n            const old = module.usedExports ? module.usedExports.length : -1;\n            module.usedExports = addToSet(module.usedExports || [], usedExports);\n            if (module.usedExports.length === old) {\n              return;\n            }\n          } else if (Array.isArray(module.usedExports)) {\n            return;\n          } else {\n            module.usedExports = false;\n          }\n\n          // for a module without side effects we stop tracking usage here when no export is used\n          // This module won't be evaluated in this case\n          if (module.factoryMeta.sideEffectFree) {\n            if (module.usedExports === false) return;\n            if (Array.isArray(module.usedExports) && module.usedExports.length === 0) return;\n          }\n          queue.push([module, module, module.usedExports]);\n        };\n        const processDependenciesBlock = (module, depBlock, usedExports) => {\n          for (const dep of depBlock.dependencies) {\n            processDependency(module, dep);\n          }\n          for (const variable of depBlock.variables) {\n            for (const dep of variable.dependencies) {\n              processDependency(module, dep);\n            }\n          }\n          for (const block of depBlock.blocks) {\n            queue.push([module, block, usedExports]);\n          }\n        };\n        const processDependency = (module, dep) => {\n          const reference = compilation.getDependencyReference(module, dep);\n          if (!reference) return;\n          const referenceModule = reference.module;\n          const importedNames = reference.importedNames;\n          const oldUsed = referenceModule.used;\n          const oldUsedExports = referenceModule.usedExports;\n          if (!oldUsed || importedNames && (!oldUsedExports || !isSubset(oldUsedExports, importedNames))) {\n            processModule(referenceModule, importedNames);\n          }\n        };\n        for (const module of modules) {\n          if (!module.used) module.used = false;\n        }\n\n        /** @type {[Module, DependenciesBlock, UsedExports][]} */\n        const queue = [];\n        for (const preparedEntrypoint of compilation._preparedEntrypoints) {\n          if (preparedEntrypoint.module) {\n            processModule(preparedEntrypoint.module, true);\n          }\n        }\n        while (queue.length) {\n          const queueItem = queue.pop();\n          processDependenciesBlock(queueItem[0], queueItem[1], queueItem[2]);\n        }\n      });\n    });\n  }\n}\nmodule.exports = FlagDependencyUsagePlugin;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}