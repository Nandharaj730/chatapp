{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\");\nconst LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nconst addToSetMap = (map, key, value) => {\n  const set = map.get(key);\n  if (set === undefined) {\n    map.set(key, new Set([value]));\n  } else {\n    set.add(value);\n  }\n};\nclass LimitChunkCountPlugin {\n  /**\n   * @param {LimitChunkCountPluginOptions=} options options object\n   */\n  constructor(options) {\n    if (!options) options = {};\n    validateOptions(schema, options, \"Limit Chunk Count Plugin\");\n    this.options = options;\n  }\n\n  /**\n   * @param {Compiler} compiler the webpack compiler\n   * @returns {void}\n   */\n  apply(compiler) {\n    const options = this.options;\n    compiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", compilation => {\n      compilation.hooks.optimizeChunksAdvanced.tap(\"LimitChunkCountPlugin\", chunks => {\n        const maxChunks = options.maxChunks;\n        if (!maxChunks) return;\n        if (maxChunks < 1) return;\n        if (chunks.length <= maxChunks) return;\n        let remainingChunksToMerge = chunks.length - maxChunks;\n\n        // order chunks in a deterministic way\n        const orderedChunks = chunks.slice().sort((a, b) => a.compareTo(b));\n\n        // create a lazy sorted data structure to keep all combinations\n        // this is large. Size = chunks * (chunks - 1) / 2\n        // It uses a multi layer bucket sort plus normal sort in the last layer\n        // It's also lazy so only accessed buckets are sorted\n        const combinations = new LazyBucketSortedSet(\n        // Layer 1: ordered by largest size benefit\n        c => c.sizeDiff, (a, b) => b - a,\n        // Layer 2: ordered by smallest combined size\n        c => c.integratedSize, (a, b) => a - b,\n        // Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n        c => c.bIdx - c.aIdx, (a, b) => a - b,\n        // Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n        (a, b) => a.bIdx - b.bIdx);\n\n        // we keep a mappng from chunk to all combinations\n        // but this mapping is not kept up-to-date with deletions\n        // so `deleted` flag need to be considered when iterating this\n        /** @type {Map<Chunk, Set<ChunkCombination>>} */\n        const combinationsByChunk = new Map();\n        orderedChunks.forEach((b, bIdx) => {\n          // create combination pairs with size and integrated size\n          for (let aIdx = 0; aIdx < bIdx; aIdx++) {\n            const a = orderedChunks[aIdx];\n            const integratedSize = a.integratedSize(b, options);\n\n            // filter pairs that do not have an integratedSize\n            // meaning they can NOT be integrated!\n            if (integratedSize === false) continue;\n            const aSize = a.size(options);\n            const bSize = b.size(options);\n            const c = {\n              deleted: false,\n              sizeDiff: aSize + bSize - integratedSize,\n              integratedSize,\n              a,\n              b,\n              aIdx,\n              bIdx,\n              aSize,\n              bSize\n            };\n            combinations.add(c);\n            addToSetMap(combinationsByChunk, a, c);\n            addToSetMap(combinationsByChunk, b, c);\n          }\n          return combinations;\n        });\n\n        // list of modified chunks during this run\n        // combinations affected by this change are skipped to allow\n        // futher optimizations\n        /** @type {Set<Chunk>} */\n        const modifiedChunks = new Set();\n        let changed = false;\n        // eslint-disable-next-line no-constant-condition\n        loop: while (true) {\n          const combination = combinations.popFirst();\n          if (combination === undefined) break;\n          combination.deleted = true;\n          const a = combination.a,\n            b = combination.b,\n            integratedSize = combination.integratedSize;\n\n          // skip over pair when\n          // one of the already merged chunks is a parent of one of the chunks\n          if (modifiedChunks.size > 0) {\n            const queue = new Set(a.groupsIterable);\n            for (const group of b.groupsIterable) {\n              queue.add(group);\n            }\n            for (const group of queue) {\n              for (const mChunk of modifiedChunks) {\n                if (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {\n                  // This is a potential pair which needs recalculation\n                  // We can't do that now, but it merge before following pairs\n                  // so we leave space for it, and consider chunks as modified\n                  // just for the worse case\n                  remainingChunksToMerge--;\n                  if (remainingChunksToMerge <= 0) break loop;\n                  modifiedChunks.add(a);\n                  modifiedChunks.add(b);\n                  continue loop;\n                }\n              }\n              for (const parent of group.parentsIterable) {\n                queue.add(parent);\n              }\n            }\n          }\n\n          // merge the chunks\n          if (a.integrate(b, \"limit\")) {\n            chunks.splice(chunks.indexOf(b), 1);\n\n            // flag chunk a as modified as further optimization are possible for all children here\n            modifiedChunks.add(a);\n            changed = true;\n            remainingChunksToMerge--;\n            if (remainingChunksToMerge <= 0) break;\n\n            // Update all affected combinations\n            // delete all combination with the removed chunk\n            // we will use combinations with the kept chunk instead\n            for (const combination of combinationsByChunk.get(b)) {\n              if (combination.deleted) continue;\n              combination.deleted = true;\n              combinations.delete(combination);\n            }\n\n            // Update combinations with the kept chunk with new sizes\n            for (const combination of combinationsByChunk.get(a)) {\n              if (combination.deleted) continue;\n              if (combination.a === a) {\n                // Update size\n                const newIntegratedSize = a.integratedSize(combination.b, options);\n                if (newIntegratedSize === false) {\n                  combination.deleted = true;\n                  combinations.delete(combination);\n                  continue;\n                }\n                const finishUpdate = combinations.startUpdate(combination);\n                combination.integratedSize = newIntegratedSize;\n                combination.aSize = integratedSize;\n                combination.sizeDiff = combination.bSize + integratedSize - newIntegratedSize;\n                finishUpdate();\n              } else if (combination.b === a) {\n                // Update size\n                const newIntegratedSize = combination.a.integratedSize(a, options);\n                if (newIntegratedSize === false) {\n                  combination.deleted = true;\n                  combinations.delete(combination);\n                  continue;\n                }\n                const finishUpdate = combinations.startUpdate(combination);\n                combination.integratedSize = newIntegratedSize;\n                combination.bSize = integratedSize;\n                combination.sizeDiff = integratedSize + combination.aSize - newIntegratedSize;\n                finishUpdate();\n              }\n            }\n          }\n        }\n        if (changed) return true;\n      });\n    });\n  }\n}\nmodule.exports = LimitChunkCountPlugin;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}