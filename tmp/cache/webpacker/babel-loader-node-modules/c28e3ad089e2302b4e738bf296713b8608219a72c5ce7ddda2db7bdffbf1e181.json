{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Gajus Kuizinas @gajus\n*/\n\"use strict\";\n\nconst WebpackError = require(\"./WebpackError\");\nconst webpackOptionsSchema = require(\"../schemas/WebpackOptions.json\");\nconst getSchemaPart = (path, parents, additionalPath) => {\n  parents = parents || 0;\n  path = path.split(\"/\");\n  path = path.slice(0, path.length - parents);\n  if (additionalPath) {\n    additionalPath = additionalPath.split(\"/\");\n    path = path.concat(additionalPath);\n  }\n  let schemaPart = webpackOptionsSchema;\n  for (let i = 1; i < path.length; i++) {\n    const inner = schemaPart[path[i]];\n    if (inner) schemaPart = inner;\n  }\n  return schemaPart;\n};\nconst getSchemaPartText = (schemaPart, additionalPath) => {\n  if (additionalPath) {\n    for (let i = 0; i < additionalPath.length; i++) {\n      const inner = schemaPart[additionalPath[i]];\n      if (inner) schemaPart = inner;\n    }\n  }\n  while (schemaPart.$ref) {\n    schemaPart = getSchemaPart(schemaPart.$ref);\n  }\n  let schemaText = WebpackOptionsValidationError.formatSchema(schemaPart);\n  if (schemaPart.description) {\n    schemaText += `\\n-> ${schemaPart.description}`;\n  }\n  return schemaText;\n};\nconst getSchemaPartDescription = schemaPart => {\n  while (schemaPart.$ref) {\n    schemaPart = getSchemaPart(schemaPart.$ref);\n  }\n  if (schemaPart.description) {\n    return `\\n-> ${schemaPart.description}`;\n  }\n  return \"\";\n};\nconst SPECIFICITY = {\n  type: 1,\n  oneOf: 1,\n  anyOf: 1,\n  allOf: 1,\n  additionalProperties: 2,\n  enum: 1,\n  instanceof: 1,\n  required: 2,\n  minimum: 2,\n  uniqueItems: 2,\n  minLength: 2,\n  minItems: 2,\n  minProperties: 2,\n  absolutePath: 2\n};\nconst filterMax = (array, fn) => {\n  const max = array.reduce((max, item) => Math.max(max, fn(item)), 0);\n  return array.filter(item => fn(item) === max);\n};\nconst filterChildren = children => {\n  children = filterMax(children, err => err.dataPath ? err.dataPath.length : 0);\n  children = filterMax(children, err => SPECIFICITY[err.keyword] || 2);\n  return children;\n};\nconst indent = (str, prefix, firstLine) => {\n  if (firstLine) {\n    return prefix + str.replace(/\\n(?!$)/g, \"\\n\" + prefix);\n  } else {\n    return str.replace(/\\n(?!$)/g, `\\n${prefix}`);\n  }\n};\nclass WebpackOptionsValidationError extends WebpackError {\n  constructor(validationErrors) {\n    super(\"Invalid configuration object. \" + \"Webpack has been initialised using a configuration object that does not match the API schema.\\n\" + validationErrors.map(err => \" - \" + indent(WebpackOptionsValidationError.formatValidationError(err), \"   \", false)).join(\"\\n\"));\n    this.name = \"WebpackOptionsValidationError\";\n    this.validationErrors = validationErrors;\n    Error.captureStackTrace(this, this.constructor);\n  }\n  static formatSchema(schema, prevSchemas) {\n    prevSchemas = prevSchemas || [];\n    const formatInnerSchema = (innerSchema, addSelf) => {\n      if (!addSelf) {\n        return WebpackOptionsValidationError.formatSchema(innerSchema, prevSchemas);\n      }\n      if (prevSchemas.includes(innerSchema)) {\n        return \"(recursive)\";\n      }\n      return WebpackOptionsValidationError.formatSchema(innerSchema, prevSchemas.concat(schema));\n    };\n    if (schema.type === \"string\") {\n      if (schema.minLength === 1) {\n        return \"non-empty string\";\n      }\n      if (schema.minLength > 1) {\n        return `string (min length ${schema.minLength})`;\n      }\n      return \"string\";\n    }\n    if (schema.type === \"boolean\") {\n      return \"boolean\";\n    }\n    if (schema.type === \"number\") {\n      return \"number\";\n    }\n    if (schema.type === \"object\") {\n      if (schema.properties) {\n        const required = schema.required || [];\n        return `object { ${Object.keys(schema.properties).map(property => {\n          if (!required.includes(property)) return property + \"?\";\n          return property;\n        }).concat(schema.additionalProperties ? [\"…\"] : []).join(\", \")} }`;\n      }\n      if (schema.additionalProperties) {\n        return `object { <key>: ${formatInnerSchema(schema.additionalProperties)} }`;\n      }\n      return \"object\";\n    }\n    if (schema.type === \"array\") {\n      return `[${formatInnerSchema(schema.items)}]`;\n    }\n    switch (schema.instanceof) {\n      case \"Function\":\n        return \"function\";\n      case \"RegExp\":\n        return \"RegExp\";\n    }\n    if (schema.enum) {\n      return schema.enum.map(item => JSON.stringify(item)).join(\" | \");\n    }\n    if (schema.$ref) {\n      return formatInnerSchema(getSchemaPart(schema.$ref), true);\n    }\n    if (schema.allOf) {\n      return schema.allOf.map(formatInnerSchema).join(\" & \");\n    }\n    if (schema.oneOf) {\n      return schema.oneOf.map(formatInnerSchema).join(\" | \");\n    }\n    if (schema.anyOf) {\n      return schema.anyOf.map(formatInnerSchema).join(\" | \");\n    }\n    return JSON.stringify(schema, null, 2);\n  }\n  static formatValidationError(err) {\n    const dataPath = `configuration${err.dataPath}`;\n    if (err.keyword === \"additionalProperties\") {\n      const baseMessage = `${dataPath} has an unknown property '${err.params.additionalProperty}'. These properties are valid:\\n${getSchemaPartText(err.parentSchema)}`;\n      if (!err.dataPath) {\n        switch (err.params.additionalProperty) {\n          case \"debug\":\n            return `${baseMessage}\\n` + \"The 'debug' property was removed in webpack 2.0.0.\\n\" + \"Loaders should be updated to allow passing this option via loader options in module.rules.\\n\" + \"Until loaders are updated one can use the LoaderOptionsPlugin to switch loaders into debug mode:\\n\" + \"plugins: [\\n\" + \"  new webpack.LoaderOptionsPlugin({\\n\" + \"    debug: true\\n\" + \"  })\\n\" + \"]\";\n        }\n        return `${baseMessage}\\n` + \"For typos: please correct them.\\n\" + \"For loader options: webpack >= v2.0.0 no longer allows custom properties in configuration.\\n\" + \"  Loaders should be updated to allow passing options via loader options in module.rules.\\n\" + \"  Until loaders are updated one can use the LoaderOptionsPlugin to pass these options to the loader:\\n\" + \"  plugins: [\\n\" + \"    new webpack.LoaderOptionsPlugin({\\n\" + \"      // test: /\\\\.xxx$/, // may apply this only for some modules\\n\" + \"      options: {\\n\" + `        ${err.params.additionalProperty}: …\\n` + \"      }\\n\" + \"    })\\n\" + \"  ]\";\n      }\n      return baseMessage;\n    } else if (err.keyword === \"oneOf\" || err.keyword === \"anyOf\") {\n      if (err.children && err.children.length > 0) {\n        if (err.schema.length === 1) {\n          const lastChild = err.children[err.children.length - 1];\n          const remainingChildren = err.children.slice(0, err.children.length - 1);\n          return WebpackOptionsValidationError.formatValidationError(Object.assign({}, lastChild, {\n            children: remainingChildren,\n            parentSchema: Object.assign({}, err.parentSchema, lastChild.parentSchema)\n          }));\n        }\n        const children = filterChildren(err.children);\n        if (children.length === 1) {\n          return WebpackOptionsValidationError.formatValidationError(children[0]);\n        }\n        return `${dataPath} should be one of these:\\n${getSchemaPartText(err.parentSchema)}\\n` + `Details:\\n${children.map(err => \" * \" + indent(WebpackOptionsValidationError.formatValidationError(err), \"   \", false)).join(\"\\n\")}`;\n      }\n      return `${dataPath} should be one of these:\\n${getSchemaPartText(err.parentSchema)}`;\n    } else if (err.keyword === \"enum\") {\n      if (err.parentSchema && err.parentSchema.enum && err.parentSchema.enum.length === 1) {\n        return `${dataPath} should be ${getSchemaPartText(err.parentSchema)}`;\n      }\n      return `${dataPath} should be one of these:\\n${getSchemaPartText(err.parentSchema)}`;\n    } else if (err.keyword === \"allOf\") {\n      return `${dataPath} should be:\\n${getSchemaPartText(err.parentSchema)}`;\n    } else if (err.keyword === \"type\") {\n      switch (err.params.type) {\n        case \"object\":\n          return `${dataPath} should be an object.${getSchemaPartDescription(err.parentSchema)}`;\n        case \"string\":\n          return `${dataPath} should be a string.${getSchemaPartDescription(err.parentSchema)}`;\n        case \"boolean\":\n          return `${dataPath} should be a boolean.${getSchemaPartDescription(err.parentSchema)}`;\n        case \"number\":\n          return `${dataPath} should be a number.${getSchemaPartDescription(err.parentSchema)}`;\n        case \"array\":\n          return `${dataPath} should be an array:\\n${getSchemaPartText(err.parentSchema)}`;\n      }\n      return `${dataPath} should be ${err.params.type}:\\n${getSchemaPartText(err.parentSchema)}`;\n    } else if (err.keyword === \"instanceof\") {\n      return `${dataPath} should be an instance of ${getSchemaPartText(err.parentSchema)}`;\n    } else if (err.keyword === \"required\") {\n      const missingProperty = err.params.missingProperty.replace(/^\\./, \"\");\n      return `${dataPath} misses the property '${missingProperty}'.\\n${getSchemaPartText(err.parentSchema, [\"properties\", missingProperty])}`;\n    } else if (err.keyword === \"minimum\") {\n      return `${dataPath} ${err.message}.${getSchemaPartDescription(err.parentSchema)}`;\n    } else if (err.keyword === \"uniqueItems\") {\n      return `${dataPath} should not contain the item '${err.data[err.params.i]}' twice.${getSchemaPartDescription(err.parentSchema)}`;\n    } else if (err.keyword === \"minLength\" || err.keyword === \"minItems\" || err.keyword === \"minProperties\") {\n      if (err.params.limit === 1) {\n        switch (err.keyword) {\n          case \"minLength\":\n            return `${dataPath} should be an non-empty string.${getSchemaPartDescription(err.parentSchema)}`;\n          case \"minItems\":\n            return `${dataPath} should be an non-empty array.${getSchemaPartDescription(err.parentSchema)}`;\n          case \"minProperties\":\n            return `${dataPath} should be an non-empty object.${getSchemaPartDescription(err.parentSchema)}`;\n        }\n        return `${dataPath} should be not empty.${getSchemaPartDescription(err.parentSchema)}`;\n      } else {\n        return `${dataPath} ${err.message}${getSchemaPartDescription(err.parentSchema)}`;\n      }\n    } else if (err.keyword === \"not\") {\n      return `${dataPath} should not be ${getSchemaPartText(err.schema)}\\n${getSchemaPartText(err.parentSchema)}`;\n    } else if (err.keyword === \"absolutePath\") {\n      const baseMessage = `${dataPath}: ${err.message}${getSchemaPartDescription(err.parentSchema)}`;\n      if (dataPath === \"configuration.output.filename\") {\n        return `${baseMessage}\\n` + \"Please use output.path to specify absolute path and output.filename for the file name.\";\n      }\n      return baseMessage;\n    } else {\n      return `${dataPath} ${err.message} (${JSON.stringify(err, null, 2)}).\\n${getSchemaPartText(err.parentSchema)}`;\n    }\n  }\n}\nmodule.exports = WebpackOptionsValidationError;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}