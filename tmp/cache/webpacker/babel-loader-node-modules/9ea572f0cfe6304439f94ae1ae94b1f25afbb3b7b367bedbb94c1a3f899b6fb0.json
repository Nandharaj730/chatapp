{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\nconst _require = require(\"webpack-sources\"),\n  ConcatSource = _require.ConcatSource,\n  RawSource = _require.RawSource;\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\nconst SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\nconst createHash = require(\"./util/createHash\");\nconst _require2 = require(\"./util/identifier\"),\n  absolutify = _require2.absolutify;\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../schemas/plugins/SourceMapDevToolPlugin.json\");\n\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"source-map\").RawSourceMap} SourceMap */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Compilation\")} SourceMapDefinition */\n\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {Array<string | Module>} [modules]\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {Chunk} chunk\n */\n\n/**\n * @param {string} name file path\n * @returns {string} file name\n */\nconst basename = name => {\n  if (!name.includes(\"/\")) return name;\n  return name.substr(name.lastIndexOf(\"/\") + 1);\n};\n\n/**\n * @type {WeakMap<Source, {file: string, assets: {[k: string]: ConcatSource | RawSource}}>}\n */\nconst assetsCache = new WeakMap();\n\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {Chunk} chunk related chunk\n * @param {SourceMapDevToolPluginOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\nconst getTaskForFile = (file, asset, chunk, options, compilation) => {\n  let source, sourceMap;\n  /**\n   * Check if asset can build source map\n   */\n  if (asset.sourceAndMap) {\n    const sourceAndMap = asset.sourceAndMap(options);\n    sourceMap = sourceAndMap.map;\n    source = sourceAndMap.source;\n  } else {\n    sourceMap = asset.map(options);\n    source = asset.source();\n  }\n  if (!sourceMap || typeof source !== \"string\") return;\n  const context = compilation.options.context;\n  const modules = sourceMap.sources.map(source => {\n    if (source.startsWith(\"webpack://\")) {\n      source = absolutify(context, source.slice(10));\n    }\n    const module = compilation.findModule(source);\n    return module || source;\n  });\n  return {\n    chunk,\n    file,\n    asset,\n    source,\n    sourceMap,\n    modules\n  };\n};\nclass SourceMapDevToolPlugin {\n  /**\n   * @param {SourceMapDevToolPluginOptions} [options] options object\n   * @throws {Error} throws error, if got more than 1 arguments\n   */\n  constructor(options) {\n    if (arguments.length > 1) {\n      throw new Error(\"SourceMapDevToolPlugin only takes one argument (pass an options object)\");\n    }\n    if (!options) options = {};\n    validateOptions(schema, options, \"SourceMap DevTool Plugin\");\n\n    /** @type {string | false} */\n    this.sourceMapFilename = options.filename;\n    /** @type {string | false} */\n    this.sourceMappingURLComment = options.append === false ? false : options.append || \"\\n//# sourceMappingURL=[url]\";\n    /** @type {string | Function} */\n    this.moduleFilenameTemplate = options.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n    /** @type {string | Function} */\n    this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || \"webpack://[namespace]/[resourcePath]?[hash]\";\n    /** @type {string} */\n    this.namespace = options.namespace || \"\";\n    /** @type {SourceMapDevToolPluginOptions} */\n    this.options = options;\n  }\n\n  /**\n   * Apply compiler\n   * @param {Compiler} compiler compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const sourceMapFilename = this.sourceMapFilename;\n    const sourceMappingURLComment = this.sourceMappingURLComment;\n    const moduleFilenameTemplate = this.moduleFilenameTemplate;\n    const namespace = this.namespace;\n    const fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n    const requestShortener = compiler.requestShortener;\n    const options = this.options;\n    options.test = options.test || /\\.(m?js|css)($|\\?)/i;\n    const matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, options);\n    compiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", compilation => {\n      new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n      compilation.hooks.afterOptimizeChunkAssets.tap( /** @type {TODO} */\n      {\n        name: \"SourceMapDevToolPlugin\",\n        context: true\n      },\n      /**\n       * @param {object} context hook context\n       * @param {Array<Chunk>} chunks resulted chunks\n       * @throws {Error} throws error, if `sourceMapFilename === false && sourceMappingURLComment === false`\n       * @returns {void}\n       */\n      (context, chunks) => {\n        /** @type {Map<string | Module, string>} */\n        const moduleToSourceNameMapping = new Map();\n        /**\n         * @type {Function}\n         * @returns {void}\n         */\n        const reportProgress = context && context.reportProgress ? context.reportProgress : () => {};\n        const files = [];\n        for (const chunk of chunks) {\n          for (const file of chunk.files) {\n            if (matchObject(file)) {\n              files.push({\n                file,\n                chunk\n              });\n            }\n          }\n        }\n        reportProgress(0.0);\n        const tasks = [];\n        files.forEach((_ref, idx) => {\n          let file = _ref.file,\n            chunk = _ref.chunk;\n          const asset = compilation.getAsset(file).source;\n          const cache = assetsCache.get(asset);\n          /**\n           * If presented in cache, reassigns assets. Cache assets already have source maps.\n           */\n          if (cache && cache.file === file) {\n            for (const cachedFile in cache.assets) {\n              if (cachedFile === file) {\n                compilation.updateAsset(cachedFile, cache.assets[cachedFile]);\n              } else {\n                compilation.emitAsset(cachedFile, cache.assets[cachedFile], {\n                  development: true\n                });\n              }\n              /**\n               * Add file to chunk, if not presented there\n               */\n              if (cachedFile !== file) chunk.files.push(cachedFile);\n            }\n            return;\n          }\n          reportProgress(0.5 * idx / files.length, file, \"generate SourceMap\");\n          /** @type {SourceMapTask | undefined} */\n          const task = getTaskForFile(file, asset, chunk, options, compilation);\n          if (task) {\n            const modules = task.modules;\n            for (let idx = 0; idx < modules.length; idx++) {\n              const module = modules[idx];\n              if (!moduleToSourceNameMapping.get(module)) {\n                moduleToSourceNameMapping.set(module, ModuleFilenameHelpers.createFilename(module, {\n                  moduleFilenameTemplate: moduleFilenameTemplate,\n                  namespace: namespace\n                }, requestShortener));\n              }\n            }\n            tasks.push(task);\n          }\n        });\n        reportProgress(0.5, \"resolve sources\");\n        /** @type {Set<string>} */\n        const usedNamesSet = new Set(moduleToSourceNameMapping.values());\n        /** @type {Set<string>} */\n        const conflictDetectionSet = new Set();\n\n        /**\n         * all modules in defined order (longest identifier first)\n         * @type {Array<string | Module>}\n         */\n        const allModules = Array.from(moduleToSourceNameMapping.keys()).sort((a, b) => {\n          const ai = typeof a === \"string\" ? a : a.identifier();\n          const bi = typeof b === \"string\" ? b : b.identifier();\n          return ai.length - bi.length;\n        });\n\n        // find modules with conflicting source names\n        for (let idx = 0; idx < allModules.length; idx++) {\n          const module = allModules[idx];\n          let sourceName = moduleToSourceNameMapping.get(module);\n          let hasName = conflictDetectionSet.has(sourceName);\n          if (!hasName) {\n            conflictDetectionSet.add(sourceName);\n            continue;\n          }\n\n          // try the fallback name first\n          sourceName = ModuleFilenameHelpers.createFilename(module, {\n            moduleFilenameTemplate: fallbackModuleFilenameTemplate,\n            namespace: namespace\n          }, requestShortener);\n          hasName = usedNamesSet.has(sourceName);\n          if (!hasName) {\n            moduleToSourceNameMapping.set(module, sourceName);\n            usedNamesSet.add(sourceName);\n            continue;\n          }\n\n          // elsewise just append stars until we have a valid name\n          while (hasName) {\n            sourceName += \"*\";\n            hasName = usedNamesSet.has(sourceName);\n          }\n          moduleToSourceNameMapping.set(module, sourceName);\n          usedNamesSet.add(sourceName);\n        }\n        tasks.forEach((task, index) => {\n          reportProgress(0.5 + 0.5 * index / tasks.length, task.file, \"attach SourceMap\");\n          const assets = Object.create(null);\n          const chunk = task.chunk;\n          const file = task.file;\n          const asset = task.asset;\n          const sourceMap = task.sourceMap;\n          const source = task.source;\n          const modules = task.modules;\n          const moduleFilenames = modules.map(m => moduleToSourceNameMapping.get(m));\n          sourceMap.sources = moduleFilenames;\n          if (options.noSources) {\n            sourceMap.sourcesContent = undefined;\n          }\n          sourceMap.sourceRoot = options.sourceRoot || \"\";\n          sourceMap.file = file;\n          assetsCache.set(asset, {\n            file,\n            assets\n          });\n          /** @type {string | false} */\n          let currentSourceMappingURLComment = sourceMappingURLComment;\n          if (currentSourceMappingURLComment !== false && /\\.css($|\\?)/i.test(file)) {\n            currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\\n\\/\\/(.*)$/, \"\\n/*$1*/\");\n          }\n          const sourceMapString = JSON.stringify(sourceMap);\n          if (sourceMapFilename) {\n            let filename = file;\n            let query = \"\";\n            const idx = filename.indexOf(\"?\");\n            if (idx >= 0) {\n              query = filename.substr(idx);\n              filename = filename.substr(0, idx);\n            }\n            const pathParams = {\n              chunk,\n              filename: options.fileContext ? path.relative(options.fileContext, filename) : filename,\n              query,\n              basename: basename(filename),\n              contentHash: createHash(\"md4\").update(sourceMapString).digest(\"hex\")\n            };\n            let sourceMapFile = compilation.getPath(sourceMapFilename, pathParams);\n            const sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile.replace(/\\\\/g, \"/\") : path.relative(path.dirname(file), sourceMapFile).replace(/\\\\/g, \"/\");\n            /**\n             * Add source map url to compilation asset, if {@link currentSourceMappingURLComment} presented\n             */\n            if (currentSourceMappingURLComment !== false) {\n              const asset = new ConcatSource(new RawSource(source), compilation.getPath(currentSourceMappingURLComment, Object.assign({\n                url: sourceMapUrl\n              }, pathParams)));\n              assets[file] = asset;\n              compilation.updateAsset(file, asset);\n            }\n            /**\n             * Add source map file to compilation assets and chunk files\n             */\n            const asset = new RawSource(sourceMapString);\n            assets[sourceMapFile] = asset;\n            compilation.emitAsset(sourceMapFile, asset, {\n              development: true\n            });\n            chunk.files.push(sourceMapFile);\n          } else {\n            if (currentSourceMappingURLComment === false) {\n              throw new Error(\"SourceMapDevToolPlugin: append can't be false when no filename is provided\");\n            }\n            /**\n             * Add source map as data url to asset\n             */\n            const asset = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\\[map\\]/g, () => sourceMapString).replace(/\\[url\\]/g, () => `data:application/json;charset=utf-8;base64,${Buffer.from(sourceMapString, \"utf-8\").toString(\"base64\")}`));\n            assets[file] = asset;\n            compilation.updateAsset(file, asset);\n          }\n        });\n        reportProgress(1.0);\n      });\n    });\n  }\n}\nmodule.exports = SourceMapDevToolPlugin;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}